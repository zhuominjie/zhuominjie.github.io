<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Quartz系列二：Cron表达式详解]]></title>
    <url>%2FQuartz%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9ACron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[CronExpression：用于配置cronTrigger的实例，由七个子表达式组成。这些表达式之间用空格分隔。 Seconds（秒） Minutes（分） Hours（小时） Day-of-Month（天） Month（月） Day-of-Week（周） Year（年） 例：”0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。 个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成”MON-FRI”，”MON,WED,FRI”，甚至”MON-WED,SAT”。 子表达式范围 Seconds (0~59) Minutes (0~59) Hours (0~23) Day-of-Month (1~31,但是要注意有些月份没有31天) Month (0~11，或者”JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC”) Day-of-Week (1~7,1=SUN 或者”SUN, MON, TUE, WED, THU, FRI, SAT”) Year (1970~2099) 字段名 允许的值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日 1-31 , - * ? / L W C 月 1-12 or JAN-DEC , - * / 周几 1-7 or SUN-SAT , - * ? / L C # 年(可选字段) empty 1970-2099 , - * / 字符含义* ：代表所有可能的值。因此，“*”在Month中表示每个月，在Day-of-Month中表示每天，在Hours表示每小时 - ：表示指定范围。 , ：表示列出枚举值。例如：在Minutes子表达式中，“5,20”表示在5分钟和20分钟触发。 / ：被用于指定增量。例如：在Minutes子表达式中，“0/15”表示从0分钟开始，每15分钟执行一次。”3/20”表示从第三分钟开始，每20分钟执行一次。和”3,23,43”（表示第3，23，43分钟触发）的含义一样。 ? ：用在Day-of-Month和Day-of-Week中，指“没有具体的值”。当两个子表达式其中一个被指定了值以后，为了避免冲突，需要将另外一个的值设为“?”。例如：想在每月20日触发调度，不管20号是星期几，只能用如下写法：0 0 0 20 ?，其中最后以为只能用“?”，而不能用“”。 L ：用在day-of-month和day-of-week字串中。它是单词“last”的缩写。它在两个子表达式中的含义是不同的。在day-of-month中，“L”表示一个月的最后一天，一月31号，3月30号。在day-of-week中，“L”表示一个星期的最后一天，也就是“7”或者“SAT”如果“L”前有具体内容，它就有其他的含义了。例如：“6L”表示这个月的倒数第六天。“FRIL”表示这个月的最后一个星期五。注意：在使用“L”参数时，不要指定列表或者范围，这样会出现问题。 W ：“Weekday”的缩写。只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日，即最后一个星期五。 # ：只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3” or “FRI#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。 表达式例子 表达式 含义 0 ? 每1分钟触发一次 0 0 * ? 每天每1小时触发一次 0 0 10 ? 每天10点触发一次 0 14 * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 30 9 1 * ? 每月1号上午9点半 0 15 10 15 * ? 每月15日上午10:15触发 /5 * ? 每隔5秒执行一次 0 /1 ? 每隔1分钟执行一次 0 0 5-15 ? 每天5-15点整点触发 0 0/3 * ? 每三分钟触发一次 0 0-5 14 ? 在每天下午2点到下午2:05期间的每1分钟触发 0 0/5 14 ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0/30 9-17 ? 朝九晚五工作时间内每半小时 0 0 10,14,16 ? 每天上午10点，下午2点，4点 0 0 12 ? * WED 表示每个星期三中午12点 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 0 23 L * ? 每月最后一天23点执行一次 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? 2005 2005年的每天上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Quartz</tag>
        <tag>持久化</tag>
        <tag>对象注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo系列三：Nginx独立部署Hexo的方法]]></title>
    <url>%2Fnginx%E9%83%A8%E7%BD%B2hexo%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[前言在自己的生产环境中部署hexo静态博客，通常有两种方法： nohup命令执行hexo s：由于hexo s是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题，不建议使用； nginx部署静态资源：将本地调试好的hexo打包生成的public目录部署到nginx上。nginx性能好，访问速度快。 Hexo配置处理二级目录：当生产环境中，静态博客部署在二级目录下（如：“http://域名(ip)/blog”这种情况），需要修改hexo工程下的_config.yml配置文件，否则打包生成的css、js文件目录会缺失（默认在根目录），导致无法加载样式。一般修改root和url,增加二级目录 # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com/blogroot: /blogpermalink: :year/:month/:day/:title/permalink_defaults: 部署在根目录无需处理 打包：通常在调试环境无需打包，修改后使用hexo s，即可生效，可以直接在本地查看效果。但是，以静态资源的方式部署需要打包生成静态资源，命令为：hexo generate。 nginx配置静态资源路由示例：hexo打包完成之后，以静态资源的方式部署到nginx，增加一个location模块。路由的细节有两种：root和alias，主要区别就是怎么解析location后面的uri。以下代码以root为例： location /blog &#123; root html; index index.html;&#125; root规则: 以上的示例，说明访问的实际路由为：html/blog/index.html alias规则: 同样的路径，alias需要按下面这么写，location后面的blog不会接到alias后面，而且alias指定的目录名后面一定要加上”/“。（^~表示uri以某个常规字符串开头，用于匹配url路径（而且不对url做编码处理，例如请求/static/20%/aa，可以被规则^~ /static/ /aa 匹配到（注意是空格））。下面是alias示例： location ^~ /blog/ &#123; alias html/blog/; index index.html;&#125; nginx常用命令 启动：nginx 停止：nginx -s stop 重启：nginx -s restart 指定配置文件启动：nginx -c 路径 参考： nginx之location（root/alias）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo系列二：Github部署站点的SEO优化教程]]></title>
    <url>%2FSEO%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF.html</url>
    <content type="text"><![CDATA[个人博客搭建完成，就算在互联网的世界里安了一个家。从阿里云的万网申请到了域名，我们的家也就有了门牌号。然而，要在茫茫人海中被人发现，仅仅靠口口相传是不够的。我们需要在黄页上登记自己的住址和成员，这样，有缘人才能登门拜访。 百度1.生成sitemap针对百度和谷歌，分别有两种hexo插件，hexo-generator-sitemap是传统的sitemap，可供谷歌使用；hexo-generator-baidu-sitemap则是针对百度。 npm install hexo-generator-sitemap --save-devnpm install hexo-generator-baidu-sitemap --save-dev 安装完成后，重启hexo，执行hexo g后，在public目录下生成对应的xml文件。本地可以通过http://127.0.0.4000/sitemap.xml和 http://127.0.0.4000/baidusitemap.xml访问到sitemap文件。 2.注册百度站长平台有百度账号即可 3.添加个人站点进入站点管理，添加网站，主要障碍在第二步的验证，方式有三：文件、html标签和cname。由于hexo会在生成编译文件的过程中，修改html文件内容，导致百度验证失败，因此，不建议再踩一遍这个坑。 由于域名是我在万网上注册的，所以选择cname的方式。过程如下： 进入万网云解析管理平台； 添加解析&gt;记录类型（CNAME），填写表单，两项必填： 主机：就是他给你的带有自身网站后缀的域名 记录值：ziyuan.baidu.com 4.提交sitemap回到链接提交处，选择自己的站点网址。找到自动提交，选择sitemap，按照提示的格式添加自己的sitemap文件 5.新增蜘蛛协议新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。 # hexo robots.txtUser-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://dadroid.cn/sitemap.xmlSitemap: http://dadroid.cn/baidusitemap.xml 然后去百度站长平台检测robots文件是否生效。 However挂了好几天，发现百度依然收录不了我的站点，登录平台查看抓取诊断-&gt;抓取一次，错误信息如下： HTTP/1.1 403 ForbiddenCache-Control: no-cacheContent-Type: text/htmlTransfer-Encoding: chunkedAccept-Ranges: bytesDate: Thu, 03 May 2018 05:57:37 GMTVia: 1.1 varnishConnection: closeX-Served-By: cache-hnd18744-HNDX-Cache: MISSX-Cache-Hits: 0X-Timer: S1525327058.780403,VS0,VE113Vary: Accept-EncodingX-Fastly-Request-ID: 7333aaaa3853b41672517dffa1a85e843dcbcdb4 可以看出该错误是拒绝访问，根据百度提供的信息可知 【访问遭拒绝】一般情况下，百度会通过跟踪网页间的链接来查找内容。百度spider必须能够访问某个网页才能抓取该网页。如果您意外地看到了“访问遭拒”错误，可能是由于以下几种原因导致的：（1）百度spider无法访问您网站上的网址，因为您网站上的所有或部分内容要求用户登录后才能查看。（2）您的服务器要求用户使用代理进行身份验证，或者您的托管服务提供商阻止百度spider访问您的网站。 说明我们托管在github pages上的博客禁止百度爬虫的访问。那么我们有什么办法能让百度收录我们的页面呢？ 托管在国内平台，如coding 采用主动/手动提交链接 由于coding绑定自定义域名免费模式会被拦截，显示coding的广告，既影响爬虫抓取站点内容，也影响美观，因此尝试过后便放弃了。下面介绍使用hexo自动提交链接的插件。 前提注册百度站长工具，然后在工具-&gt;网页抓取-&gt;链接提交里找到你的密匙。 hexo-baidu-url-submit首先，在Hexo根目录下，安装本插件：npm install hexo-baidu-url-submit --save 然后，同样在根目录下，把以下内容配置到_config.yml文件中: baidu_url_submit: count: 1 ## 提交最新的一个链接 host: www.hui-wang.info ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 其次，记得查看_config.ym文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如: # URLurl: http://www.dadroid.cnroot: /permalink: 最后，加入新的deployer: deploy:- type: git ## 这是我原来的deployer- type: baidu_url_submitter ## 这是新加的 实现原理 新链接的产生，hexo generate会产生一个文本文件，里面包含最新的链接 新链接的提交，hexo deploy会从上述文件中读取链接，提交至百度搜索引擎 谷歌步骤1——5与百度大同小异，以下介绍一些不同点： 1.注册Google Search Console链接：https://www.google.com/webmasters/ 2.抓取方式完成robost检测后，点击左侧的Google抓取方式。 在这里我们填上我们需要抓取的url，不填这表示抓取首页，抓取方式可以选择桌面，智能手机，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。 提交完成后，提交至索引，根据提示操作就可以了 hexo优化修改文章链接Hexo默认的文章链接形式是一个四级url——domain/year/month/day/postname，可能造成url过长，对搜索引擎是十分不友好。我们可以改成domain/postname的形式，编辑站点_config.yml文件，修改permalink字段改为permalink: :title.html即可。 keywords 和 description在hexo工程根目录下的\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。 keywords:description: 给出站链接添加 “nofollow” 标签网络爬虫可能在搜索当前页面的所有链接时，跳到别的网站回不来了。因此，需要nofollow标签发挥作用。 nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 Hexo的Next主题需要改以下几个地方： 找到footer.swig，路径在your-hexo-site\themes\next\layout\_partials，将下面代码中的a标签加上rel=&quot;external nofollow&quot;属性； &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125; &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码中的a标签加上rel=&quot;external nofollow&quot;属性； &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; &lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码：&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改为：&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz系列一：基本用法总结]]></title>
    <url>%2FQuartz%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[OpenSymphony所提供的Quartz是任务调度领域享誉盛名的开源框架。Spring提供了集成Quartz的功能，可以让开发人员以更面向Spring的方式创建基于Quartz的任务调度应用。任务调度本身设计多线程并发、运行时间规则制定及解析、运行现场保持与恢复、线程池维护等诸多方面的工作。如果以自定义线程池的原始方法开发，难点很大。 1.普通JAVA任务启动基本的Quartz任务包含一下流程： 创建任务类：实现Job接口的void execute(JobExecutionContext context)方法，定义被执行任务的执行逻辑； 生成JobDetail对象：通过加载任务类（不是实例）来绑定任务逻辑与任务信息； 生成Trigger对象：定时器的触发时间有两种方式可以定义，分别是CronSchedule和simpleSchedule()。前者使用正则表达式，后者则是简单封装后的定时器。 获取Scheduler对象：通过StdSchedulerFactory工厂方法初始化scheduler对象，把任务和定时器绑定在一起，并启动任务。 完整实例代码import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Date;public class RAMQuartz &#123; private static Logger logger = LoggerFactory.getLogger(RAMQuartz.class); public static void main(String[] args) throws SchedulerException &#123; //创建scheduler SchedulerFactory sf = new StdSchedulerFactory(); Scheduler scheduler = sf.getScheduler(); //定义一个JobDetail //定义Job类为RAMJob类，这是真正的执行逻辑所在 JobDetail jb = JobBuilder.newJob(RAMJob1.class) .withDescription("this is a ram job") .withIdentity("ramJob", "ramGroup")//定义name/group .build(); //通过JobDataMap传递参数 jb.getJobDataMap().put("Test", "This is test parameter value"); long time = System.currentTimeMillis() + 3*1000L; Date startTime = new Date(time); //定义一个Trigger Trigger trigger = TriggerBuilder.newTrigger() .withDescription("") .withIdentity("ramTrigger", "ramTriggerGroup")//定义name/group .startAt(startTime)//加入scheduler后，在指定时间启动 //使用CronTrigger .withSchedule(CronScheduleBuilder.cronSchedule("0/2 * * * * ?")) .build(); //绑定任务和定时器到调度器 scheduler.scheduleJob(jb,trigger); //启动 scheduler.start(); logger.info("启动时间 ： " + new Date()); &#125;&#125; import org.quartz.Job;import org.quartz.JobDataMap;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import java.util.Date;public class RAMJob1 implements Job&#123; private static Logger logger = LoggerFactory.getLogger(RAMJob.class); @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; try &#123; JobDataMap dataMap = jobExecutionContext.getJobDetail().getJobDataMap(); String str = dataMap.getString("Test"); logger.info("Quartz dataMap : " + new Date() + "\n" + str); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.对象注入在Spring的WEB应用中使用定时器，通常都会用到spring的特性——对象注入。前面的代码虽然能够很好地执行简单的定时器任务，但是遇到复杂的执行逻辑（如数据库读写等），就不能应付了。 下面代码可以看出，任务2需要执行myBatis的数据库插入语句： public class RAMJob2 implements Job&#123; @Autowired private TestQuartzMapper testQuartzMapper; private static Logger logger = LoggerFactory.getLogger(RAMJob.class); @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; try &#123; testQuartzMapper.insertSelective(testQuartz); logger.info("Insert MyBatis Success!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行这个业务逻辑，就不得不注入对象。如果仍然延用上面的方法，我们会发现执行的时候，testQuartzMapper的对象为null，结果自然毫无悬念地不断报错。 如何为我们的定时器注入Spring的对象，下面介绍一下思路： 自定义JobFactory工厂方法，扩展AdaptableJobFactory，重写其createJobInstance方法； 声明SchedulerFactoryBean，传入自定义的JobFactory工厂方法； 通过新的SchedulerFactoryBean获取scheduler实例，用注入的方式在需要的地方使用。 完整示例import org.quartz.spi.TriggerFiredBundle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.AutowireCapableBeanFactory;import org.springframework.scheduling.quartz.AdaptableJobFactory;import org.springframework.stereotype.Component;@Componentpublic class MyJobFactory extends AdaptableJobFactory &#123; @Autowired private AutowireCapableBeanFactory capableBeanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; // 调用父类的方法 Object jobInstance = super.createJobInstance(bundle); // 进行注入 capableBeanFactory.autowireBean(jobInstance); return jobInstance; &#125;&#125; @Configurationpublic class QuartzConfig &#123; @Autowired private MyJobFactory myJobFactory; @Bean public SchedulerFactoryBean schedulerFactoryBean() throws IOException &#123; SchedulerFactoryBean factory = new SchedulerFactoryBean(); // 加载quartz数据源配置 factory.setQuartzProperties(quartzProperties()); // 自定义Job Factory，用于Spring注入 factory.setJobFactory(myJobFactory); return factory; &#125; @Bean public Scheduler scheduler() throws IOException, SchedulerException &#123; Scheduler scheduler = schedulerFactoryBean().getScheduler(); scheduler.start(); return scheduler; &#125;&#125; 3.Spring简单任务Spring对Quartz进行了封装，方便开发者调用。下面以Spring Boot为例，介绍一下简单任务在Spring的执行方式。 任务类定义仔细观察可以发现，与普通Java任务的区别在于使用了@Component和@EnableScheduling的注释，相应的，就不用声明implements Job，以及重写execute方法。这是Spring提供的一种便利。 @Component@EnableSchedulingpublic class SpringJob &#123; @Autowired WriteService writeService; private Logger logger = LoggerFactory.getLogger(this.getClass()); public void myJobBusinessMethod() &#123; this.logger.info("MyFirstExerciseJob哇被触发了哈哈哈哈哈"); writeService.writeMSG("张三"); &#125;&#125; 配置JobDetail和Trigger的BeanMethodInvokingJobDetailFactoryBean是Spring提供的JobDetail工厂方法，使用它可以快速地定义JobDetail。然而，缺点是生成的任务无法持久化保存，也就是说，无法管理任务的启动、暂停、恢复、停止等操作。CronTriggerFactoryBean为表达式型触发器。 @Configurationpublic class QuartzJobConfig &#123; /** * 方法调用任务明细工厂Bean */ @Bean(name = "SpringJobBean") public MethodInvokingJobDetailFactoryBean myFirstExerciseJobBean(SpringJob springJob) &#123; MethodInvokingJobDetailFactoryBean jobDetail = new MethodInvokingJobDetailFactoryBean(); jobDetail.setConcurrent(false); // 是否并发 jobDetail.setName("general-springJob"); // 任务的名字 jobDetail.setGroup("general"); // 任务的分组 jobDetail.setTargetObject(springJob); // 被执行的对象 jobDetail.setTargetMethod("myJobBusinessMethod"); // 被执行的方法 return jobDetail; &#125; /** * 表达式触发器工厂Bean */ @Bean(name = "SpringJobTrigger") public CronTriggerFactoryBean myFirstExerciseJobTrigger(@Qualifier("SpringJobBean") MethodInvokingJobDetailFactoryBean springJobBean) &#123; CronTriggerFactoryBean tigger = new CronTriggerFactoryBean(); tigger.setJobDetail(springJobBean.getObject()); tigger.setCronExpression("0/10 * * * * ?"); // 什么是否触发，Spring Scheduler Cron表达式 tigger.setName("general-springJobTrigger"); return tigger; &#125;&#125; 调度器下面将任务和触发器注册到调度器 @Configurationpublic class QuartzConfig &#123; /** * 调度器工厂Bean */ @Bean(name = "schedulerFactory") public SchedulerFactoryBean schedulerFactory(@Qualifier("SpringJobTrigger") Trigger springJobTrigger) &#123; SchedulerFactoryBean bean = new SchedulerFactoryBean(); // 覆盖已存在的任务 bean.setOverwriteExistingJobs(true); // 延时启动定时任务，避免系统未完全启动却开始执行定时任务的情况 bean.setStartupDelay(15); // 注册触发器 bean.setTriggers(SpringJobTrigger); return bean; &#125;&#125; 完成上述配置后，启动spring boot就可以出发定时器任务了。而且，仔细观察上面的代码，在执行过程中有WriteService的spring对象注入，而无需我们自己去自定义JobFactory的Spring对象。 4.持久化任务持久化需要用到数据库，而初始化数据库的SQL可以从下载的发布版的文件中找到，比如，我在官网的Download页下载了当前版本的Full Distribution：Quartz 2.2.3 .tar.gz，解压后在quartz-2.2.3\docs\dbTables能找到初始化脚本，因我用的是MySQL的Innodb引擎，所以我用此脚本tables_mysql_innodb.sql。 配置默认情况下，调度器的详情信息会被存储在内存，模式为：RAMJobStore，而且也不需要填写quartz.properties的配置。然而，如果是持久化的模式，那么quartz.properties就必须填写，因为文件中制定了信息存储模式和数据源信息。 # 线程调度器实例名org.quartz.scheduler.instanceName = quartzScheduler# 线程池的线程数，即最多3个任务同时跑org.quartz.threadPool.threadCount = 3# 如何存储任务和触发器等信息org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX# 驱动代理org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate# 表前缀org.quartz.jobStore.tablePrefix = qrtz_ # 数据源org.quartz.jobStore.dataSource = quartzDataSource# 是否集群org.quartz.jobStore.isClustered = false# 数据源# 驱动org.quartz.dataSource.quartzDataSource.driver = com.mysql.cj.jdbc.Driver# 连接URLorg.quartz.dataSource.quartzDataSource.URL = jdbc:mysql://localhost:3306/quartz?characterEncoding=utf-8&amp;useSSL=true&amp;&amp;serverTimezone=Asia/Shanghai# 用户名org.quartz.dataSource.quartzDataSource.user = root# 密码org.quartz.dataSource.quartzDataSource.password = 123456# 最大连接数org.quartz.dataSource.quartzDataSource.maxConnections = 5 其他内容和RAMJobStore模式相同。 这里，记录下一个大坑：完成上面的配置之后，仍然无法连接到数据库，报错的内容是C3P0的connectionProvider初始化失败。查了很多资料，再结合错误信息，花了半天时间，才发现：原来quartz默认使用了C3P0的数据源，然而quartz的依赖包中并没有C3P0的依赖，因此无法初始化连接器。解决方法：只要在maven管理的POM.xml中把C3P0的依赖加上就可以了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Quartz</tag>
        <tag>持久化</tag>
        <tag>对象注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA服务通过URL下载文件]]></title>
    <url>%2FJAVA%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%BF%87URL%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[如何通过Java（模拟浏览器）发送HTTP请求，下载文件是WEB应用经常处理的场景。Java有原生的API可用于发送HTTP请求，即：java.net.URL、java.net.URLConnection。这些API本身已经足够好用，但不够简便。所以，也流行有许多Java HTTP请求的framework，如Apache的HttpClient等。 目前项目主要用到Java原生的方式，所以，这里主要介绍此方式。 1.Get请求和Post请求HTTP请求简单分为GET请求和POST请求（详见：Hypertext Transfer Protocol – HTTP/1.1 - Method Definitions）。 使用Java发送这两种请求的代码大同小异，只是一些参数设置的不同。步骤如下： 通过统一资源定位器（java.net.URL）获取连接器（java.net.URLConnection） 设置请求的参数 发送请求 以输入流的形式获取返回内容 关闭输入流 HttpURLConnection继承自URLConnection，常用它下面几个方法： -setRequestMethod：设置URL请求的方法， 如GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE。其中，GET方法是默认的，可以不写； -setRequestProperty：设置一般请求属性，如”Accept-Charset”、”Content-Type”、”User-Agent”等； -getResponseCode：从HTTP响应消息获取状态码； -getResponseMessage：获取与来自服务器的响应代码一起返回的HTTP响应消息（如果有）。 2.下载文件文件下载请求，本质上也是一个POST请求，因此，流程大体相同。下面的示例正是按照流程顺序进行了处理。如果项目中有多处地方使用HTTP请求，我们可以适当对其进行封装。 封装文件下载器/** * 从网络Url中下载文件 * @param urlStr * @param fileName * @param savePath * @throws IOException */public static void downLoadFromUrl(String urlStr,String fileName,String savePath) throws IOException&#123; URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); //设置超时间为3秒 conn.setConnectTimeout(3*1000); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)"); //得到输入流 InputStream inputStream = conn.getInputStream(); //转储文件 saveToLocal(inputStream, savePath, fileName); System.out.println("info:"+url+" download success");&#125; 执行文件转储/** * 文件转储 * @param in * @param fileName * @param savePath * @throws IOException */public static void saveToLocal(InputStream in, String fileName, String savePath) throws IOException &#123; //获取字节流 byte[] getData = readInputStream(in); //父文件夹位置 File saveDir = new File(savePath); if(!saveDir.exists())&#123; saveDir.mkdir(); &#125; File file = new File(saveDir+File.separator+fileName); FileOutputStream fos = new FileOutputStream(file); fos.write(getData); //关闭输入输出流 if(fos!=null)&#123; fos.close(); &#125; if(in!=null)&#123; in.close(); &#125;&#125; 输入流转字节流/** * 从输入流中获取字节数组 * @param inputStream * @return * @throws IOException */public static byte[] readInputStream(InputStream inputStream) throws IOException &#123; byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while((len = inputStream.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.close(); return bos.toByteArray();&#125; 参考：如果想学习如何用URLConnection发送Get请求和Post请求，可参考这篇好文：通过java.net.URLConnection发送HTTP请求的方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>URLConnection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo系列一：NexT主题优化之路]]></title>
    <url>%2Fhexo-next%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF.html</url>
    <content type="text"><![CDATA[选择了Hexo + Next完成个人博客建站之后，仍然会有很多不足之处。此时，万能的搜索引擎和git社区为我们提供了琳琅满目的解决方案。本文将陆续记录本站采用过的优化措施，以供大家参考。 缩小首页文章列表间距并增加阴影效果在5.1.3版本中，可以直接修改next/source/css/_custom/custom.styl文件，如下： // 主页文章添加阴影效果.posts-expand &#123; .post &#123; margin-top: 60px; margin-bottom: 20px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;&#125; 增加标签步骤一你需要在hexo根目录的source文件夹下新建一个tags文件夹，然后在tags文件夹里面新建一个index.md文件。快捷命令为： hexo new page "tags" 步骤二编辑source/tags/index.md文件，内容如下： ---title: &quot;tags&quot;type: tagslayout: &quot;tags&quot;comments: false--- title标题不重要，自定义。comments为false，可以关闭本页的评论功能。 步骤三编辑主题配置文件 nav: home: / about: /about tags: /tags 步骤四文章中多个标签的添加方式如下： tags: - tag1 - tag2 或者 tags: [tag1, tag2] 增加分类方法同上，区别是: tags换成categories; 分类只能有一个。 文章中增加categories: xxx。 添加站内搜索安装插件支持站内搜索需要hexo-generator-search和hexo-generator-searchdb两个插件，在站点的根目录下执行以下命令： npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 启用搜索第一步：在hexo的_config.yml配置文件增加如下内容： search: path: search.xml field: post format: html limit: 10000 第二步：在NexT的_config.yml配置文件修改如下内容： local_search: enable: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>tags</tag>
        <tag>文章阴影</tag>
        <tag>文章列表间距</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
</search>
