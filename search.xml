<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微服务[Exception]：Zuul无法访问负载均衡服务]]></title>
    <url>%2Fposts%2F8e887edc%2F</url>
    <content type="text"><![CDATA[问题描述使用zuul的负载均衡功能时，无法访问负载均衡服务 先决条件 使用Eureka作为服务注册 zuul配置路由匹配规则为服务化的路由规则 异常如下15:50:18.013 Gateway [http-nio-9090-exec-6] WARN o.s.c.n.z.f.post.SendErrorFilter - Error during filteringcom.netflix.zuul.exception.ZuulException: Forwarding error at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.handleException(RibbonRoutingFilter.java:189) at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.forward(RibbonRoutingFilter.java:164) at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.run(RibbonRoutingFilter.java:111) at com.netflix.zuul.ZuulFilter.runFilter(ZuulFilter.java:112) at com.netflix.zuul.FilterProcessor.processZuulFilter(FilterProcessor.java:193) at com.netflix.zuul.FilterProcessor.runFilters(FilterProcessor.java:157) at com.netflix.zuul.FilterProcessor.route(FilterProcessor.java:118) at com.netflix.zuul.ZuulRunner.route(ZuulRunner.java:96) at com.netflix.zuul.http.ZuulServlet.route(ZuulServlet.java:116) at com.netflix.zuul.http.ZuulServlet.service(ZuulServlet.java:81) at org.springframework.web.servlet.mvc.ServletWrappingController.handleRequestInternal(ServletWrappingController.java:157) at org.springframework.cloud.netflix.zuul.web.ZuulController.handleRequest(ZuulController.java:44) at org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter.handle(SimpleControllerHandlerAdapter.java:50) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:317) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:114) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at com.cmcc.cmct.gateway.auth.AuthenticationTokenProcessingFilter.doFilter(AuthenticationTokenProcessingFilter.java:47) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:64) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)Caused by: com.netflix.client.ClientException: null at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:118) at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:152) at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:49) at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302) at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:46) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.subscribe(Observable.java:10247) at rx.Observable.subscribe(Observable.java:10214) at rx.internal.operators.BlockingOperatorToFuture.toFuture(BlockingOperatorToFuture.java:51) at rx.observables.BlockingObservable.toFuture(BlockingObservable.java:411) at com.netflix.hystrix.HystrixCommand.queue(HystrixCommand.java:378) at com.netflix.hystrix.HystrixCommand.execute(HystrixCommand.java:344) at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.forward(RibbonRoutingFilter.java:158) ... 105 common frames omittedCaused by: java.lang.RuntimeException: java.net.UnknownHostException: xntest02.gzhl.quality: 未知的名称或服务 at rx.exceptions.Exceptions.propagate(Exceptions.java:58) at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:464) at rx.observables.BlockingObservable.single(BlockingObservable.java:341) at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:112) ... 167 common frames omittedCaused by: java.net.UnknownHostException: xntest02.gzhl.quality: 未知的名称或服务 at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method) at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:928) at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1323) at java.net.InetAddress.getAllByName0(InetAddress.java:1276) at java.net.InetAddress.getAllByName(InetAddress.java:1192) at java.net.InetAddress.getAllByName(InetAddress.java:1126) at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45) at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112) at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:359) at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:381) at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:237) at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:185) at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89) at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:111) at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108) at org.springframework.cloud.netflix.ribbon.apache.RibbonLoadBalancingHttpClient.execute(RibbonLoadBalancingHttpClient.java:82) at org.springframework.cloud.netflix.ribbon.apache.RibbonLoadBalancingHttpClient.execute(RibbonLoadBalancingHttpClient.java:42) at com.netflix.client.AbstractLoadBalancerAwareClient$1.call(AbstractLoadBalancerAwareClient.java:104) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:303) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:287) at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:231) at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:228) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286) at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:185) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:180) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94) at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42) at rx.Observable.unsafeSubscribe(Observable.java:10151) at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:127) at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:73) at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:52) at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:79) at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45) at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276) at rx.Subscriber.setProducer(Subscriber.java:209) at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138) at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.subscribe(Observable.java:10247) at rx.Observable.subscribe(Observable.java:10214) at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:444) ... 169 common frames omitted 分析根据如下两部分的异常内容，通常会认为是Ribbon和Hystrix的超时问题。 异常一： com.netflix.zuul.exception.ZuulException: Forwarding error at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.handleException(RibbonRoutingFilter.java:189) at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.forward(RibbonRoutingFilter.java:164) at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.run(RibbonRoutingFilter.java:111) ...... 异常二： Caused by: com.netflix.client.ClientException: null at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:118) at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:152) at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:49) at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302) at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298) 相应的解决方案： ribbon.ConnectTimeout=60000ribbon.ReadTimeout=60000hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=120000 然而 不幸的是，我加了这两个超时配置之后，并没有改变zuul负载均衡转发异常。唯一改变的是：在每次异常发生时，请求的等待时间被大大延长。抓狂~~~~ 通过多次的本地实验，我才开始对异常三产生了重视，内容如下：异常三： Caused by: java.net.UnknownHostException: xntest02.gzhl.quality: 未知的名称或服务 at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method) at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:928) at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1323) 是的，重点在这里。尽管负载均衡器在启动的时候就发现了可以用于分担压力的三个节点，然而，这些节点信息都是Eureka提供的。我们的当地主机虽然获得了这些节点的hostname，却根本不知道如何去访问它们。 zuul启动时获取的服务注册信息 16:07:42.327 Gateway [main] INFO c.n.l.DynamicServerListLoadBalancer - DynamicServerListLoadBalancer for client CloudAPI initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=CloudAPI,current list of Servers=[xntest02.gzhl.quality:9000, xntest03.gzhl.quality:9000, xntest01.gzhl.quality:9000],Load balancer stats=Zone stats: &#123;defaultzone=[Zone:defaultzone; Instance count:3; Active connections count: 0; Circuit breaker tripped count: 0; Active connections per server: 0.0;]&#125;,Server stats: [[Server:xntest03.gzhl.quality:9000; Zone:defaultZone; Total Requests:0; Successive connection failure:0; Total blackout seconds:0; Last connection made:Thu Jan 01 08:00:00 CST 1970; First connection made: Thu Jan 01 08:00:00 CST 1970; Active Connections:0; total failure count in last (1000) msecs:0; average resp time:0.0; 90 percentile resp time:0.0; 95 percentile resp time:0.0; min resp time:0.0; max resp time:0.0; stddev resp time:0.0], [Server:xntest01.gzhl.quality:9000; Zone:defaultZone; Total Requests:0; Successive connection failure:0; Total blackout seconds:0; Last connection made:Thu Jan 01 08:00:00 CST 1970; First connection made: Thu Jan 01 08:00:00 CST 1970; Active Connections:0; total failure count in last (1000) msecs:0; average resp time:0.0; 90 percentile resp time:0.0; 95 percentile resp time:0.0; min resp time:0.0; max resp time:0.0; stddev resp time:0.0], [Server:xntest02.gzhl.quality:9000; Zone:defaultZone; Total Requests:0; Successive connection failure:0; Total blackout seconds:0; Last connection made:Thu Jan 01 08:00:00 CST 1970; First connection made: Thu Jan 01 08:00:00 CST 1970; Active Connections:0; total failure count in last (1000) msecs:0; average resp time:0.0; 90 percentile resp time:0.0; 95 percentile resp time:0.0; min resp time:0.0; max resp time:0.0; stddev resp time:0.0]]&#125; 看到这儿，解决方案也就出来了。那就是，确保每一个服务所在的服务器节点都能通过hostname和zuul网关互通。从操作角度来说，就是要在每一台服务节点上配置其他所有服务节点的hostname，使得这些服务集群互通。 Liunx解决方案：第一步 打开配置文件 vi /etc/hosts 第二步 增加服务所在主机ip对应的hostname 172.23.25.1 xntest01172.23.25.2 xntest02172.23.25.3 xntest03 大功告成~~~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>zuul</tag>
        <tag>eureka</tag>
        <tag>micro service</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务：Zuul代理转发]]></title>
    <url>%2Fposts%2Fb778229b%2F</url>
    <content type="text"><![CDATA[Zuul代理转发zuul代理转发的方式有两种： URL映射：优点是不用对被代理的服务做任务修改，适合旧系统迁移到微服务架构时采用。过渡状态中，通常会保留旧代码继续使用，同时逐步将功能一点点迁移到新平台。旧功能的访问便可以采用这种方法，使得项目可以在用户毫无感知的情况下迁移到微服务架构。缺点是每增加一个服务就需要配置一条内容，不支持动态提供后端的服务。服务化映射：在实现微服务架构时，服务名与服务实例地址的关系在eureka server中已经存在了，所以只需要将Zuul注册到eureka server上去发现其他服务，就可以实现对serviceId的映射。 URL映射客户端存在context-path客户端application.property配置 spring.application.name=service-cloudappserver.context-path=/SPLD 说明: 直接访问路径为——http://ip:port/SPLD/api zuulapplication.property配置 #注册Eureka服务发现eureka.client.serviceUrl.defaultZone: http://localhost:8060/eureka/#转发zuul.routes.app.path=/SPLD/**zuul.routes.app.serviceId=service-cloudapp 那么访问路径是：http://ip:port/SPLD/SPLD/api 如何去掉重复的前缀呢？可以在zuul中，路由后面增加配置如下： zuul.routes.app.stripPrefix=false 原理 当stripPrefix=true的时候，代理前缀默认会从请求路径中移除。访问http://zuul-ip:port/SPLD/api重定向到http://spld-ip:port/api 当stripPrefix=false的时候，会保留代理前缀。访问http://zuul-ip:port/SPLD/api会重定向到http://spld-ip:port/SPLD/api。 参考文章：springcloud(十)：服务网关zuul]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>zuul</tag>
        <tag>micro service</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx：常用命令]]></title>
    <url>%2Fposts%2Fcbdebe31%2F</url>
    <content type="text"><![CDATA[SCP-文件传输从服务器下载文件scp username@servername:/remote_path/filename ~/local_destination 从服务器下载整个目录scp -r username@servername:/remote_path/remote_dir/ ~/local_destination 上传本地文件到服务器scp ~/local_path/local_filename username@servername:/remote_path 上传目录到服务器scp -r ~/local_dir username@servername:/remote_path/remote_dir]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库：MyBatis常用语法]]></title>
    <url>%2Fposts%2F5a838215%2F</url>
    <content type="text"><![CDATA[Else判断分支使用MyBatis写动态SQL查询相比Hiberntate是非常方便的。select不仅能够根据mapper接口中的返回值自动匹配 查询selectOne还是selectList，而且在查询中还可以灵活的定制查询的方式，添加if 或者 choose等标签进行查询。mybaits中没有else要用“chose when otherwise”代替 &lt;!--批量插入用户--&gt;&lt;select id="getItems" parameterType="com.ipro.shopping.to.IntegerEntity" resultType="itemsType"&gt; select * from itemsType &lt;where&gt; &lt;!--方式一使用choose的方式查询--&gt; &lt;!-- &lt;choose&gt; &lt;when test="parentId !=0 "&gt;parentTypeId=#&#123;parentId&#125;&lt;/when&gt; &lt;when test="parentId==0"&gt;parentTypeId is null&lt;/when&gt; &lt;/choose&gt; --&gt; &lt;!--方式二使用if的方式查询--&gt; &lt;if test="parentId!=0"&gt; parentTypeId=#&#123;parentId&#125; &lt;/if&gt; &lt;if test="parentId==0"&gt; parentTypeId is null &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz：Cron表达式详解]]></title>
    <url>%2Fposts%2Ff507bee4%2F</url>
    <content type="text"><![CDATA[CronExpression：用于配置cronTrigger的实例，由七个子表达式组成。这些表达式之间用空格分隔。 Seconds（秒） Minutes（分） Hours（小时） Day-of-Month（天） Month（月） Day-of-Week（周） Year（年） 例：”0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。 个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成”MON-FRI”，”MON,WED,FRI”，甚至”MON-WED,SAT”。 子表达式范围 Seconds (0~59) Minutes (0~59) Hours (0~23) Day-of-Month (1~31,但是要注意有些月份没有31天) Month (0~11，或者”JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC”) Day-of-Week (1~7,1=SUN 或者”SUN, MON, TUE, WED, THU, FRI, SAT”) Year (1970~2099) 字段名 允许的值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日 1-31 , - * ? / L W C 月 1-12 or JAN-DEC , - * / 周几 1-7 or SUN-SAT , - * ? / L C # 年(可选字段) empty 1970-2099 , - * / 字符含义* ：代表所有可能的值。因此，“*”在Month中表示每个月，在Day-of-Month中表示每天，在Hours表示每小时 - ：表示指定范围。 , ：表示列出枚举值。例如：在Minutes子表达式中，“5,20”表示在5分钟和20分钟触发。 / ：被用于指定增量。例如：在Minutes子表达式中，“0/15”表示从0分钟开始，每15分钟执行一次。”3/20”表示从第三分钟开始，每20分钟执行一次。和”3,23,43”（表示第3，23，43分钟触发）的含义一样。 ? ：用在Day-of-Month和Day-of-Week中，指“没有具体的值”。当两个子表达式其中一个被指定了值以后，为了避免冲突，需要将另外一个的值设为“?”。例如：想在每月20日触发调度，不管20号是星期几，只能用如下写法：0 0 0 20 ?，其中最后以为只能用“?”，而不能用“”。 L ：用在day-of-month和day-of-week字串中。它是单词“last”的缩写。它在两个子表达式中的含义是不同的。在day-of-month中，“L”表示一个月的最后一天，一月31号，3月30号。在day-of-week中，“L”表示一个星期的最后一天，也就是“7”或者“SAT”如果“L”前有具体内容，它就有其他的含义了。例如：“6L”表示这个月的倒数第六天。“FRIL”表示这个月的最后一个星期五。注意：在使用“L”参数时，不要指定列表或者范围，这样会出现问题。 W ：“Weekday”的缩写。只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日，即最后一个星期五。 # ：只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3” or “FRI#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。 表达式例子 表达式 含义 0 ? 每1分钟触发一次 0 0 * ? 每天每1小时触发一次 0 0 10 ? 每天10点触发一次 0 14 * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 30 9 1 * ? 每月1号上午9点半 0 15 10 15 * ? 每月15日上午10:15触发 /5 * ? 每隔5秒执行一次 0 /1 ? 每隔1分钟执行一次 0 0 5-15 ? 每天5-15点整点触发 0 0/3 * ? 每三分钟触发一次 0 0-5 14 ? 在每天下午2点到下午2:05期间的每1分钟触发 0 0/5 14 ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0/30 9-17 ? 朝九晚五工作时间内每半小时 0 0 10,14,16 ? 每天上午10点，下午2点，4点 0 0 12 ? * WED 表示每个星期三中午12点 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 0 23 L * ? 每月最后一天23点执行一次 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? 2005 2005年的每天上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Quartz</tag>
        <tag>持久化</tag>
        <tag>对象注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：Nginx独立部署方法]]></title>
    <url>%2Fposts%2F3a8571de%2F</url>
    <content type="text"><![CDATA[前言在自己的生产环境中部署hexo静态博客，通常有两种方法：nohup命令：通过nohup执行hexo s实现。由于hexo s是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题，不建议使用；Nginx服务器：通过nginx部署静态资源，将本地调试好的hexo工程打包生成的public目录部署到nginx上。nginx性能好，访问速度快。 Hexo配置处理二级目录：当生产环境中，静态博客部署在二级目录下（如：“http://域名(ip)/blog”这种情况），需要修改hexo工程下的_config.yml配置文件，否则打包生成的css、js文件目录会缺失（默认在根目录），导致无法加载样式。一般修改root和url,增加二级目录 # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' ## and root as '/child/'url: http://yoursite.com/blogroot: /blogpermalink: :year/:month/:day/:title/permalink_defaults: 部署在根目录无需处理 打包：通常在调试环境无需打包，修改后使用hexo s，即可生效，可以直接在本地查看效果。但是，以静态资源的方式部署需要打包生成静态资源，命令为：hexo generate。 Nginx配置静态资源路由示例：hexo打包完成之后，以静态资源的方式部署到nginx，增加一个location模块。路由的细节有两种：root和alias，主要区别就是怎么解析location后面的uri。以下代码以root为例： location /blog &#123; root html; index index.html;&#125; root规则: 以上的示例，说明访问的实际路由为：html/blog/index.html alias规则: 同样的路径，alias需要按下面这么写，location后面的blog不会接到alias后面，而且alias指定的目录名后面一定要加上”/“。（^~表示uri以某个常规字符串开头，用于匹配url路径（而且不对url做编码处理，例如请求/static/20%/aa，可以被规则^~ /static/ /aa 匹配到（注意是空格））。下面是alias示例： location ^~ /blog/ &#123; alias html/blog/; index index.html;&#125; Nginx常用命令 启动：nginx 停止：nginx -s stop 重启：nginx -s restart 指定配置文件启动：nginx -c 路径 参考： nginx之location（root/alias）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：Github部署站点的SEO优化教程]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[个人博客搭建完成，就算在互联网的世界里安了一个家。从阿里云的万网申请到了域名，我们的家也就有了门牌号。然而，要在茫茫人海中被人发现，仅仅靠口口相传是不够的。我们需要在黄页上登记自己的住址和成员，这样，有缘人才能登门拜访。 百度1.生成sitemap针对百度和谷歌，分别有两种hexo插件，hexo-generator-sitemap是传统的sitemap，可供谷歌使用；hexo-generator-baidu-sitemap则是针对百度。 npm install hexo-generator-sitemap --save-devnpm install hexo-generator-baidu-sitemap --save-dev 安装完成后，重启hexo，执行hexo g后，在public目录下生成对应的xml文件。本地可以通过http://127.0.0.4000/sitemap.xml和 http://127.0.0.4000/baidusitemap.xml访问到sitemap文件。 2.注册百度站长平台有百度账号即可 3.添加个人站点进入站点管理，添加网站，主要障碍在第二步的验证，方式有三：文件、html标签和cname。由于hexo会在生成编译文件的过程中，修改html文件内容，导致百度验证失败，因此，不建议再踩一遍这个坑。 由于域名是我在万网上注册的，所以选择cname的方式。过程如下： 进入万网云解析管理平台； 添加解析&gt;记录类型（CNAME），填写表单，两项必填： 主机：就是他给你的带有自身网站后缀的域名 记录值：ziyuan.baidu.com 4.提交sitemap回到链接提交处，选择自己的站点网址。找到自动提交，选择sitemap，按照提示的格式添加自己的sitemap文件 5.新增蜘蛛协议新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。 # hexo robots.txtUser-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://dadroid.cn/sitemap.xmlSitemap: http://dadroid.cn/baidusitemap.xml 然后去百度站长平台检测robots文件是否生效。 However挂了好几天，发现百度依然收录不了我的站点，登录平台查看抓取诊断-&gt;抓取一次，错误信息如下： HTTP/1.1 403 ForbiddenCache-Control: no-cacheContent-Type: text/htmlTransfer-Encoding: chunkedAccept-Ranges: bytesDate: Thu, 03 May 2018 05:57:37 GMTVia: 1.1 varnishConnection: closeX-Served-By: cache-hnd18744-HNDX-Cache: MISSX-Cache-Hits: 0X-Timer: S1525327058.780403,VS0,VE113Vary: Accept-EncodingX-Fastly-Request-ID: 7333aaaa3853b41672517dffa1a85e843dcbcdb4 可以看出该错误是拒绝访问，根据百度提供的信息可知 【访问遭拒绝】一般情况下，百度会通过跟踪网页间的链接来查找内容。百度spider必须能够访问某个网页才能抓取该网页。如果您意外地看到了“访问遭拒”错误，可能是由于以下几种原因导致的：（1）百度spider无法访问您网站上的网址，因为您网站上的所有或部分内容要求用户登录后才能查看。（2）您的服务器要求用户使用代理进行身份验证，或者您的托管服务提供商阻止百度spider访问您的网站。 说明我们托管在github pages上的博客禁止百度爬虫的访问。那么我们有什么办法能让百度收录我们的页面呢？ 托管在国内平台，如coding 采用主动/手动提交链接 由于coding绑定自定义域名免费模式会被拦截，显示coding的广告，既影响爬虫抓取站点内容，也影响美观，因此尝试过后便放弃了。下面介绍使用hexo自动提交链接的插件。 前提注册百度站长工具，然后在工具-&gt;网页抓取-&gt;链接提交里找到你的密匙。 hexo-baidu-url-submit首先，在Hexo根目录下，安装本插件：npm install hexo-baidu-url-submit --save 然后，同样在根目录下，把以下内容配置到_config.yml文件中: baidu_url_submit: count: 1 ## 提交最新的一个链接 host: www.hui-wang.info ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 其次，记得查看_config.ym文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如: # URLurl: http://www.dadroid.cnroot: /permalink: 最后，加入新的deployer: deploy:- type: git ## 这是我原来的deployer- type: baidu_url_submitter ## 这是新加的 实现原理 新链接的产生，hexo generate会产生一个文本文件，里面包含最新的链接 新链接的提交，hexo deploy会从上述文件中读取链接，提交至百度搜索引擎 谷歌步骤1——5与百度大同小异，以下介绍一些不同点： 1.注册Google Search Console链接：https://www.google.com/webmasters/ 2.抓取方式完成robost检测后，点击左侧的Google抓取方式。 在这里我们填上我们需要抓取的url，不填这表示抓取首页，抓取方式可以选择桌面，智能手机，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。 提交完成后，提交至索引，根据提示操作就可以了 hexo优化修改文章链接Hexo默认的文章链接形式是一个四级url——domain/year/month/day/postname，可能造成url过长，对搜索引擎是十分不友好。我们可以改成domain/postname的形式，编辑站点_config.yml文件，修改permalink字段改为permalink: :title.html即可。 keywords 和 description在hexo工程根目录下的\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。 keywords:description: 给出站链接添加 “nofollow” 标签网络爬虫可能在搜索当前页面的所有链接时，跳到别的网站回不来了。因此，需要nofollow标签发挥作用。 nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 Hexo的Next主题需要改以下几个地方： 找到footer.swig，路径在your-hexo-site\themes\next\layout\_partials，将下面代码中的a标签加上rel=&quot;external nofollow&quot;属性； &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125; &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码中的a标签加上rel=&quot;external nofollow&quot;属性； &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; &lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码：&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改为：&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz：基本用法总结]]></title>
    <url>%2Fposts%2Ff6df2318%2F</url>
    <content type="text"><![CDATA[OpenSymphony所提供的Quartz是任务调度领域享誉盛名的开源框架。Spring提供了集成Quartz的功能，可以让开发人员以更面向Spring的方式创建基于Quartz的任务调度应用。任务调度本身设计多线程并发、运行时间规则制定及解析、运行现场保持与恢复、线程池维护等诸多方面的工作。如果以自定义线程池的原始方法开发，难点很大。 1.普通JAVA任务启动基本的Quartz任务包含一下流程： 创建任务类：实现Job接口的void execute(JobExecutionContext context)方法，定义被执行任务的执行逻辑； 生成JobDetail对象：通过加载任务类（不是实例）来绑定任务逻辑与任务信息； 生成Trigger对象：定时器的触发时间有两种方式可以定义，分别是CronSchedule和simpleSchedule()。前者使用正则表达式，后者则是简单封装后的定时器。 获取Scheduler对象：通过StdSchedulerFactory工厂方法初始化scheduler对象，把任务和定时器绑定在一起，并启动任务。 完整实例代码import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Date;public class RAMQuartz &#123; private static Logger logger = LoggerFactory.getLogger(RAMQuartz.class); public static void main(String[] args) throws SchedulerException &#123; //创建scheduler SchedulerFactory sf = new StdSchedulerFactory(); Scheduler scheduler = sf.getScheduler(); //定义一个JobDetail //定义Job类为RAMJob类，这是真正的执行逻辑所在 JobDetail jb = JobBuilder.newJob(RAMJob1.class) .withDescription("this is a ram job") .withIdentity("ramJob", "ramGroup")//定义name/group .build(); //通过JobDataMap传递参数 jb.getJobDataMap().put("Test", "This is test parameter value"); long time = System.currentTimeMillis() + 3*1000L; Date startTime = new Date(time); //定义一个Trigger Trigger trigger = TriggerBuilder.newTrigger() .withDescription("") .withIdentity("ramTrigger", "ramTriggerGroup")//定义name/group .startAt(startTime)//加入scheduler后，在指定时间启动 //使用CronTrigger .withSchedule(CronScheduleBuilder.cronSchedule("0/2 * * * * ?")) .build(); //绑定任务和定时器到调度器 scheduler.scheduleJob(jb,trigger); //启动 scheduler.start(); logger.info("启动时间 ： " + new Date()); &#125;&#125; import org.quartz.Job;import org.quartz.JobDataMap;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import java.util.Date;public class RAMJob1 implements Job&#123; private static Logger logger = LoggerFactory.getLogger(RAMJob.class); @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; try &#123; JobDataMap dataMap = jobExecutionContext.getJobDetail().getJobDataMap(); String str = dataMap.getString("Test"); logger.info("Quartz dataMap : " + new Date() + "\n" + str); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.对象注入在Spring的WEB应用中使用定时器，通常都会用到spring的特性——对象注入。前面的代码虽然能够很好地执行简单的定时器任务，但是遇到复杂的执行逻辑（如数据库读写等），就不能应付了。 下面代码可以看出，任务2需要执行myBatis的数据库插入语句： public class RAMJob2 implements Job&#123; @Autowired private TestQuartzMapper testQuartzMapper; private static Logger logger = LoggerFactory.getLogger(RAMJob.class); @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; try &#123; testQuartzMapper.insertSelective(testQuartz); logger.info("Insert MyBatis Success!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行这个业务逻辑，就不得不注入对象。如果仍然延用上面的方法，我们会发现执行的时候，testQuartzMapper的对象为null，结果自然毫无悬念地不断报错。 如何为我们的定时器注入Spring的对象，下面介绍一下思路： 自定义JobFactory工厂方法，扩展AdaptableJobFactory，重写其createJobInstance方法； 声明SchedulerFactoryBean，传入自定义的JobFactory工厂方法； 通过新的SchedulerFactoryBean获取scheduler实例，用注入的方式在需要的地方使用。 完整示例import org.quartz.spi.TriggerFiredBundle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.AutowireCapableBeanFactory;import org.springframework.scheduling.quartz.AdaptableJobFactory;import org.springframework.stereotype.Component;@Componentpublic class MyJobFactory extends AdaptableJobFactory &#123; @Autowired private AutowireCapableBeanFactory capableBeanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; // 调用父类的方法 Object jobInstance = super.createJobInstance(bundle); // 进行注入 capableBeanFactory.autowireBean(jobInstance); return jobInstance; &#125;&#125; @Configurationpublic class QuartzConfig &#123; @Autowired private MyJobFactory myJobFactory; @Bean public SchedulerFactoryBean schedulerFactoryBean() throws IOException &#123; SchedulerFactoryBean factory = new SchedulerFactoryBean(); // 加载quartz数据源配置 factory.setQuartzProperties(quartzProperties()); // 自定义Job Factory，用于Spring注入 factory.setJobFactory(myJobFactory); return factory; &#125; @Bean public Scheduler scheduler() throws IOException, SchedulerException &#123; Scheduler scheduler = schedulerFactoryBean().getScheduler(); scheduler.start(); return scheduler; &#125;&#125; 3.Spring简单任务Spring对Quartz进行了封装，方便开发者调用。下面以Spring Boot为例，介绍一下简单任务在Spring的执行方式。 任务类定义仔细观察可以发现，与普通Java任务的区别在于使用了@Component和@EnableScheduling的注释，相应的，就不用声明implements Job，以及重写execute方法。这是Spring提供的一种便利。 @Component@EnableSchedulingpublic class SpringJob &#123; @Autowired WriteService writeService; private Logger logger = LoggerFactory.getLogger(this.getClass()); public void myJobBusinessMethod() &#123; this.logger.info("MyFirstExerciseJob哇被触发了哈哈哈哈哈"); writeService.writeMSG("张三"); &#125;&#125; 配置JobDetail和Trigger的BeanMethodInvokingJobDetailFactoryBean是Spring提供的JobDetail工厂方法，使用它可以快速地定义JobDetail。然而，缺点是生成的任务无法持久化保存，也就是说，无法管理任务的启动、暂停、恢复、停止等操作。CronTriggerFactoryBean为表达式型触发器。 @Configurationpublic class QuartzJobConfig &#123; /** * 方法调用任务明细工厂Bean */ @Bean(name = "SpringJobBean") public MethodInvokingJobDetailFactoryBean myFirstExerciseJobBean(SpringJob springJob) &#123; MethodInvokingJobDetailFactoryBean jobDetail = new MethodInvokingJobDetailFactoryBean(); jobDetail.setConcurrent(false); // 是否并发 jobDetail.setName("general-springJob"); // 任务的名字 jobDetail.setGroup("general"); // 任务的分组 jobDetail.setTargetObject(springJob); // 被执行的对象 jobDetail.setTargetMethod("myJobBusinessMethod"); // 被执行的方法 return jobDetail; &#125; /** * 表达式触发器工厂Bean */ @Bean(name = "SpringJobTrigger") public CronTriggerFactoryBean myFirstExerciseJobTrigger(@Qualifier("SpringJobBean") MethodInvokingJobDetailFactoryBean springJobBean) &#123; CronTriggerFactoryBean tigger = new CronTriggerFactoryBean(); tigger.setJobDetail(springJobBean.getObject()); tigger.setCronExpression("0/10 * * * * ?"); // 什么是否触发，Spring Scheduler Cron表达式 tigger.setName("general-springJobTrigger"); return tigger; &#125;&#125; 调度器下面将任务和触发器注册到调度器 @Configurationpublic class QuartzConfig &#123; /** * 调度器工厂Bean */ @Bean(name = "schedulerFactory") public SchedulerFactoryBean schedulerFactory(@Qualifier("SpringJobTrigger") Trigger springJobTrigger) &#123; SchedulerFactoryBean bean = new SchedulerFactoryBean(); // 覆盖已存在的任务 bean.setOverwriteExistingJobs(true); // 延时启动定时任务，避免系统未完全启动却开始执行定时任务的情况 bean.setStartupDelay(15); // 注册触发器 bean.setTriggers(SpringJobTrigger); return bean; &#125;&#125; 完成上述配置后，启动spring boot就可以出发定时器任务了。而且，仔细观察上面的代码，在执行过程中有WriteService的spring对象注入，而无需我们自己去自定义JobFactory的Spring对象。 4.持久化任务持久化需要用到数据库，而初始化数据库的SQL可以从下载的发布版的文件中找到，比如，我在官网的Download页下载了当前版本的Full Distribution：Quartz 2.2.3 .tar.gz，解压后在quartz-2.2.3\docs\dbTables能找到初始化脚本，因我用的是MySQL的Innodb引擎，所以我用此脚本tables_mysql_innodb.sql。 配置默认情况下，调度器的详情信息会被存储在内存，模式为：RAMJobStore，而且也不需要填写quartz.properties的配置。然而，如果是持久化的模式，那么quartz.properties就必须填写，因为文件中制定了信息存储模式和数据源信息。 # 线程调度器实例名org.quartz.scheduler.instanceName = quartzScheduler# 线程池的线程数，即最多3个任务同时跑org.quartz.threadPool.threadCount = 3# 如何存储任务和触发器等信息org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX# 驱动代理org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate# 表前缀org.quartz.jobStore.tablePrefix = qrtz_ # 数据源org.quartz.jobStore.dataSource = quartzDataSource# 是否集群org.quartz.jobStore.isClustered = false# 数据源# 驱动org.quartz.dataSource.quartzDataSource.driver = com.mysql.cj.jdbc.Driver# 连接URLorg.quartz.dataSource.quartzDataSource.URL = jdbc:mysql://localhost:3306/quartz?characterEncoding=utf-8&amp;useSSL=true&amp;&amp;serverTimezone=Asia/Shanghai# 用户名org.quartz.dataSource.quartzDataSource.user = root# 密码org.quartz.dataSource.quartzDataSource.password = 123456# 最大连接数org.quartz.dataSource.quartzDataSource.maxConnections = 5 其他内容和RAMJobStore模式相同。 这里，记录下一个大坑：完成上面的配置之后，仍然无法连接到数据库，报错的内容是C3P0的connectionProvider初始化失败。查了很多资料，再结合错误信息，花了半天时间，才发现：原来quartz默认使用了C3P0的数据源，然而quartz的依赖包中并没有C3P0的依赖，因此无法初始化连接器。解决方法：只要在maven管理的POM.xml中把C3P0的依赖加上就可以了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Quartz</tag>
        <tag>持久化</tag>
        <tag>对象注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：NexT主题优化之路]]></title>
    <url>%2Fposts%2Fdc01d1e2%2F</url>
    <content type="text"><![CDATA[选择了Hexo + Next完成个人博客建站之后，仍然会有很多不足之处。此时，万能的搜索引擎和git社区为我们提供了琳琅满目的解决方案。本文将陆续记录本站采用过的优化措施，以供大家参考。 缩小首页文章列表间距并增加阴影效果在5.1.3版本中，可以直接修改next/source/css/_custom/custom.styl文件，如下： // 主页文章添加阴影效果.posts-expand &#123; .post &#123; margin-top: 60px; margin-bottom: 20px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;&#125; 增加标签步骤一你需要在hexo根目录的source文件夹下新建一个tags文件夹，然后在tags文件夹里面新建一个index.md文件。快捷命令为： hexo new page "tags" 步骤二编辑source/tags/index.md文件，内容如下： ---title: &quot;tags&quot;type: tagslayout: &quot;tags&quot;comments: false--- title标题不重要，自定义。comments为false，可以关闭本页的评论功能。 步骤三编辑主题配置文件 nav: home: / about: /about tags: /tags 步骤四文章中多个标签的添加方式如下： tags: - tag1 - tag2 或者 tags: [tag1, tag2] 增加分类方法同上，区别是: tags换成categories; 分类只能有一个。 文章中增加categories: xxx。 添加站内搜索安装插件支持站内搜索需要hexo-generator-search和hexo-generator-searchdb两个插件，在站点的根目录下执行以下命令： npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 启用搜索第一步：在hexo的_config.yml配置文件增加如下内容： search: path: search.xml field: post format: html limit: 10000 第二步：在NexT的_config.yml配置文件修改如下内容： local_search: enable: true 修改Pisces主题内容区宽度默认的宽度觉得有点窄，想改宽一点，可以在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码: /*扩展宽度*/header&#123; width: 80% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 80%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 去掉图片默认的边框将Next主题/themes/next/source/css/_common/components/post/post-expand.styl文件中的img的border的值修改为none //将border的值修改为none即可去掉边框，默认值为 1px solid $gray-lighter img &#123; box-sizing: border-box; margin: auto; padding: 3px; border: none; &#125; 持久化链接优化写的文章复制到微信中链接被分开了，无法直接点击链接访问。看了其他人的博客，大多数是转换为英文的，也没说实现方法。看到一个abbrlink的方法，使用解决了这一问题。 安装abbr-link插件npm install hexo-abbrlink --save 配置博客站点文件permalink: posts/:abbrlink/# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex 部署执行hexo clean和hexo s，使得配置生效]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>tags</tag>
        <tag>文章阴影</tag>
        <tag>文章列表间距</tag>
        <tag>搜索，Pisces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA：文件下载]]></title>
    <url>%2Fposts%2Fc0372a48%2F</url>
    <content type="text"><![CDATA[如何通过Java（模拟浏览器）发送HTTP请求，下载文件是WEB应用经常处理的场景。Java有原生的API可用于发送HTTP请求，即：java.net.URL、java.net.URLConnection。这些API本身已经足够好用，但不够简便。所以，也流行有许多Java HTTP请求的framework，如Apache的HttpClient等。 目前项目主要用到Java原生的方式，所以，这里主要介绍此方式。 1.Get请求和Post请求HTTP请求简单分为GET请求和POST请求（详见：Hypertext Transfer Protocol – HTTP/1.1 - Method Definitions）。 使用Java发送这两种请求的代码大同小异，只是一些参数设置的不同。步骤如下： 通过统一资源定位器（java.net.URL）获取连接器（java.net.URLConnection） 设置请求的参数 发送请求 以输入流的形式获取返回内容 关闭输入流 HttpURLConnection继承自URLConnection，常用它下面几个方法： -setRequestMethod：设置URL请求的方法， 如GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE。其中，GET方法是默认的，可以不写； -setRequestProperty：设置一般请求属性，如”Accept-Charset”、”Content-Type”、”User-Agent”等； -getResponseCode：从HTTP响应消息获取状态码； -getResponseMessage：获取与来自服务器的响应代码一起返回的HTTP响应消息（如果有）。 2.下载文件文件下载请求，本质上也是一个POST请求，因此，流程大体相同。下面的示例正是按照流程顺序进行了处理。如果项目中有多处地方使用HTTP请求，我们可以适当对其进行封装。 封装文件下载器/** * 从网络Url中下载文件 * @param urlStr * @param fileName * @param savePath * @throws IOException */public static void downLoadFromUrl(String urlStr,String fileName,String savePath) throws IOException&#123; URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); //设置超时间为3秒 conn.setConnectTimeout(3*1000); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)"); //得到输入流 InputStream inputStream = conn.getInputStream(); //转储文件 saveToLocal(inputStream, savePath, fileName); System.out.println("info:"+url+" download success");&#125; 执行文件转储/** * 文件转储 * @param in * @param fileName * @param savePath * @throws IOException */public static void saveToLocal(InputStream in, String fileName, String savePath) throws IOException &#123; //获取字节流 byte[] getData = readInputStream(in); //父文件夹位置 File saveDir = new File(savePath); if(!saveDir.exists())&#123; saveDir.mkdir(); &#125; File file = new File(saveDir+File.separator+fileName); FileOutputStream fos = new FileOutputStream(file); fos.write(getData); //关闭输入输出流 if(fos!=null)&#123; fos.close(); &#125; if(in!=null)&#123; in.close(); &#125;&#125; 输入流转字节流/** * 从输入流中获取字节数组 * @param inputStream * @return * @throws IOException */public static byte[] readInputStream(InputStream inputStream) throws IOException &#123; byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while((len = inputStream.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.close(); return bos.toByteArray();&#125; 参考：如果想学习如何用URLConnection发送Get请求和Post请求，可参考这篇好文：通过java.net.URLConnection发送HTTP请求的方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>URLConnection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[足迹：龙门古镇]]></title>
    <url>%2Fposts%2F7fc1a8e1%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：六和塔]]></title>
    <url>%2Fposts%2F55828a88%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：九溪十八涧]]></title>
    <url>%2Fposts%2Fcaeb5da5%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：湘湖]]></title>
    <url>%2Fposts%2F2500110d%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：白马湖]]></title>
    <url>%2Fposts%2F58ecbb5a%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：千岛湖]]></title>
    <url>%2Fposts%2F20a3881c%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：乌镇]]></title>
    <url>%2Fposts%2F5f961822%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[足迹：迪士尼]]></title>
    <url>%2Fposts%2Fb2af91bf%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
