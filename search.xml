<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Appium-环境部署</title>
      <link href="/posts/42fc8a9/"/>
      <url>/posts/42fc8a9/</url>
      <content type="html"><![CDATA[<h1 id="安装Java-jdk1-8"><a href="#安装Java-jdk1-8" class="headerlink" title="安装Java jdk1.8"></a>安装Java jdk1.8</h1><h4 id="搭建环境："><a href="#搭建环境：" class="headerlink" title="搭建环境："></a>搭建环境：</h4><p>Ubuntu 16.04 x64<br>JDK :jdk-8u171-linux-x64.tar.gz</p><h4 id="下载linux对应的安装包"><a href="#下载linux对应的安装包" class="headerlink" title="下载linux对应的安装包"></a>下载linux对应的安装包</h4><p>下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><h4 id="解压安装包jdk-8u171-linux-x64-tar-gz"><a href="#解压安装包jdk-8u171-linux-x64-tar-gz" class="headerlink" title="解压安装包jdk-8u171-linux-x64.tar.gz"></a>解压安装包jdk-8u171-linux-x64.tar.gz</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="转移目录到-usr-lib-目录下"><a href="#转移目录到-usr-lib-目录下" class="headerlink" title="转移目录到 /usr/lib 目录下"></a>转移目录到 /usr/lib 目录下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  /usr/lib</span><br><span class="line">sudo mkdir jdk</span><br><span class="line">sudo mv ~/jdk1.8.0_171/ usr/lib/jdk</span><br></pre></td></tr></table></figure><h4 id="配置java环境变量"><a href="#配置java环境变量" class="headerlink" title="配置java环境变量"></a>配置java环境变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/bash.bashrc</span><br></pre></td></tr></table></figure><p>在末尾加以下几行文字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java env</span><br><span class="line">export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_171</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre    </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib    </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>执行命令使修改立即生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h4><p>在终端输入，出现版本号则表示安装成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h1 id="安装-Android-SDK"><a href="#安装-Android-SDK" class="headerlink" title="安装 Android SDK"></a>安装 Android SDK</h1><h4 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h4><p>Android SDK中的adb程序是32位的，Ubuntu x64系统需要安装32位库文件，用于兼容32位的程序。如果不安装，adb会出错：java.io.IOException: error=2<br>输入下面命令，安装库文件（国内需先换源）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure><h4 id="下载-SDK-Tools"><a href="#下载-SDK-Tools" class="headerlink" title="下载 SDK Tools"></a>下载 SDK Tools</h4><p>地址：<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a><br>在<code>AndroidDevTools</code>中下载<code>SDK Tools</code>，在<code>Downloads</code>文件夹下找到下载的文件，并将<code>android-linux-sdk</code>移动到<code>/opt/</code>目录下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv /Download/android-sdk-linux /opt/</span><br></pre></td></tr></table></figure><h4 id="配置Android-SDK-环境变量"><a href="#配置Android-SDK-环境变量" class="headerlink" title="配置Android SDK 环境变量"></a>配置Android SDK 环境变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/bash.bashrc</span><br></pre></td></tr></table></figure><p>在末尾增加如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ANDROID_SDK_HOME=/opt/android-sdk-linux</span><br><span class="line">export PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125;/tools</span><br><span class="line">export PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125;/platform-tools</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>RabbitMQ:配置SSL安全访问</title>
      <link href="/posts/348c654f/"/>
      <url>/posts/348c654f/</url>
      <content type="html"><![CDATA[<h2 id="一、生成-SSL-证书"><a href="#一、生成-SSL-证书" class="headerlink" title="一、生成 SSL 证书"></a>一、生成 SSL 证书</h2><p>SSL(Secure Sockets Layer 安全套接层)，及其继任者<code>传输层安全</code>（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。<code>TLS</code>与<code>SSL</code>在传输层对网络连接进行加密，一般可分为<code>单向认证</code>和<code>双向认证</code>。<code>RabbitMQ</code> 采用的是双向认证方式。</p><h4 id="1-创建目录"><a href="#1-创建目录" class="headerlink" title="1.创建目录"></a>1.创建目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir testca</span><br><span class="line"># cd testca</span><br><span class="line"># mkdir certs private</span><br><span class="line"># chmod 700 private</span><br><span class="line"># echo 01 &gt; serial</span><br><span class="line"># touch index.txt</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-在该目录下，生成openssl-cnf文件，内容如下："><a href="#2-在该目录下，生成openssl-cnf文件，内容如下：" class="headerlink" title="2.在该目录下，生成openssl.cnf文件，内容如下："></a>2.在该目录下，生成<code>openssl.cnf</code>文件，内容如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ ca ]</span><br><span class="line">default_ca = testca</span><br><span class="line"></span><br><span class="line">[ testca ]</span><br><span class="line">dir = .</span><br><span class="line">certificate = $dir/cacert.pem</span><br><span class="line">database = $dir/index.txt</span><br><span class="line">new_certs_dir = $dir/certs</span><br><span class="line">private_key = $dir/private/cakey.pem</span><br><span class="line">serial = $dir/serial</span><br><span class="line"></span><br><span class="line">default_crl_days = 7</span><br><span class="line">default_days = 365</span><br><span class="line">default_md = sha256</span><br><span class="line"></span><br><span class="line">policy = testca_policy</span><br><span class="line">x509_extensions = certificate_extensions</span><br><span class="line"></span><br><span class="line">[ testca_policy ]</span><br><span class="line">commonName = supplied</span><br><span class="line">stateOrProvinceName = optional</span><br><span class="line">countryName = optional</span><br><span class="line">emailAddress = optional</span><br><span class="line">organizationName = optional</span><br><span class="line">organizationalUnitName = optional</span><br><span class="line">domainComponent = optional</span><br><span class="line"></span><br><span class="line">[ certificate_extensions ]</span><br><span class="line">basicConstraints = CA:false</span><br><span class="line"></span><br><span class="line">[ req ]</span><br><span class="line">default_bits = 2048</span><br><span class="line">default_keyfile = ./private/cakey.pem</span><br><span class="line">default_md = sha256</span><br><span class="line">prompt = yes</span><br><span class="line">distinguished_name = root_ca_distinguished_name</span><br><span class="line">x509_extensions = root_ca_extensions</span><br><span class="line"></span><br><span class="line">[ root_ca_distinguished_name ]</span><br><span class="line">commonName = hostname</span><br><span class="line"></span><br><span class="line">[ root_ca_extensions ]</span><br><span class="line">basicConstraints = CA:true</span><br><span class="line">keyUsage = keyCertSign, cRLSign</span><br><span class="line"></span><br><span class="line">[ client_ca_extensions ]</span><br><span class="line">basicConstraints = CA:false</span><br><span class="line">keyUsage = digitalSignature</span><br><span class="line">extendedKeyUsage = 1.3.6.1.5.5.7.3.2</span><br><span class="line"></span><br><span class="line">[ server_ca_extensions ]</span><br><span class="line">basicConstraints = CA:false</span><br><span class="line">keyUsage = keyEncipherment</span><br><span class="line">extendedKeyUsage = 1.3.6.1.5.5.7.3.1</span><br></pre></td></tr></table></figure><h4 id="3-颁发自己的-CA-证书"><a href="#3-颁发自己的-CA-证书" class="headerlink" title="3.颁发自己的 CA 证书"></a>3.颁发自己的 CA 证书</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># openssl req -x509 -config openssl.cnf -newkey rsa:2048 -days 365 -out cacert.pem -outform PEM -subj /CN=MyTestCA/ -nodes</span><br><span class="line"># openssl x509 -in cacert.pem -out cacert.cer -outform DER</span><br></pre></td></tr></table></figure><h4 id="4-生成服务器证书"><a href="#4-生成服务器证书" class="headerlink" title="4.生成服务器证书"></a>4.生成服务器证书</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd ..</span><br><span class="line"># ls</span><br><span class="line">testca</span><br><span class="line"># mkdir server</span><br><span class="line"># cd server</span><br><span class="line"># openssl genrsa -out key.pem 2048</span><br><span class="line"># openssl req -new -key key.pem -out req.pem -outform PEM -subj /CN=$(hostname)/O=server/ -nodes</span><br><span class="line"># cd ../testca</span><br><span class="line"># openssl ca -config openssl.cnf -in ../server/req.pem -out ../server/cert.pem -notext -batch -extensions server_ca_extensions</span><br><span class="line"># cd ../server</span><br><span class="line"># openssl pkcs12 -export -out keycert.p12 -in cert.pem -inkey key.pem -passout pass:MySecretPassword</span><br></pre></td></tr></table></figure><h4 id="5-生成客户端证书"><a href="#5-生成客户端证书" class="headerlink" title="5.生成客户端证书"></a>5.生成客户端证书</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd ..</span><br><span class="line"># ls</span><br><span class="line">server testca</span><br><span class="line"># mkdir client</span><br><span class="line"># cd client</span><br><span class="line"># openssl genrsa -out key.pem 2048</span><br><span class="line"># openssl req -new -key key.pem -out req.pem -outform PEM -subj /CN=$(hostname)/O=client/ -nodes</span><br><span class="line"># cd ../testca</span><br><span class="line"># openssl ca -config openssl.cnf -in ../client/req.pem -out ../client/cert.pem -notext -batch -extensions client_ca_extensions</span><br><span class="line"># cd ../client</span><br><span class="line"># openssl pkcs12 -export -out keycert.p12 -in cert.pem -inkey key.pem -passout pass:MySecretPassword</span><br></pre></td></tr></table></figure><p>后续需要要使用的文件分别是：<code>testca/cacert.pem</code>、<code>server/cert.pem</code>、<code>server/key.pem</code>、<code>client/cert.pem</code>、<code>client/key.pem</code>、<code>client/keycert.p12</code></p><h4 id="6-番外"><a href="#6-番外" class="headerlink" title="6.番外"></a>6.番外</h4><p>此外，生成证书的过程也有git上的大神写好的<code>shell</code>脚本可以使用，项目地址为：<br><a href="https://github.com/Berico-Technologies/CMF-AMQP-Configuration" target="_blank" rel="noopener">https://github.com/Berico-Technologies/CMF-AMQP-Configuration</a></p><p>可直接通过git命令进行clone到本地（最好新建个文件夹AMQPSSL）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Berico-Technologies/CMF-AMQP-Configuration.git</span><br></pre></td></tr></table></figure><p>在clone后的项目目录中，doc文件夹下有详细的说明shell脚本如何使用。</p><ol><li>确保已经安装好了openssl，具体安装方法请自行google；</li></ol><p>切换到 CMF-AMQP-Configuration/ssl 文件夹，运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh setup_ca.sh MyRabbitMQCA</span><br></pre></td></tr></table></figure><p>名称定义为”MyRabbitMQCA”，这个名字可以自行指定，用于在证书中显示证书颁发机构名。</p><ol start="2"><li>生成服务器证书</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh make_server_cert.sh rabbitmq-server rabbit</span><br></pre></td></tr></table></figure><p>一个参数是服务器名，第二个参数是密码。</p><ol start="3"><li>生成客户端证书</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh create_client_cert.sh rabbit-client rabbit</span><br></pre></td></tr></table></figure><p>第一个参数是客户端名称，第二个参数是密码。</p><p>执行完以上步骤之后，会在ssl目录下生成：ca、server、client三个文件夹。</p><h2 id="二、配置-RabbitMQ-服务器"><a href="#二、配置-RabbitMQ-服务器" class="headerlink" title="二、配置 RabbitMQ 服务器"></a>二、配置 RabbitMQ 服务器</h2><h4 id="1-配置RabbitMQ环境"><a href="#1-配置RabbitMQ环境" class="headerlink" title="1.配置RabbitMQ环境"></a>1.配置RabbitMQ环境</h4><p>Mac上RabbitMQ的配置文件通常位于<code>/usr/local/etc/rabbitmq</code>，在该目录下创建<code>rabbitmq.conf</code>和<code>advanced.config</code>两个文件，并修改<code>rabbitmq-env.conf</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_FILE=/usr/local/etc/rabbitmq/rabbitmq</span><br><span class="line">RABBITMQ_ADVANCED_CONFIG_FILE=//usr/local/etc/rabbitmq/advanced</span><br><span class="line">#NODE_IP_ADDRESS=127.0.0.1</span><br><span class="line">NODENAME=rabbit@localhost</span><br></pre></td></tr></table></figure><h4 id="2-基本配置-rabbitmq-conf-修改"><a href="#2-基本配置-rabbitmq-conf-修改" class="headerlink" title="2.基本配置 rabbitmq.conf 修改"></a>2.基本配置 rabbitmq.conf 修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listeners.ssl.default=5671</span><br><span class="line">  </span><br><span class="line">ssl_options.cacertfile=/usr/local/etc/rabbitmq/ca/cacert.pem</span><br><span class="line">ssl_options.certfile=/usr/local/etc/rabbitmq/ca/cert.pem</span><br><span class="line">ssl_options.keyfile=/usr/local/etc/rabbitmq/ca/key.pem</span><br><span class="line">ssl_options.verify=verify_peer</span><br><span class="line">ssl_options.fail_if_no_peer_cert=false</span><br></pre></td></tr></table></figure><h4 id="3-高级配置-advanced-config-修改"><a href="#3-高级配置-advanced-config-修改" class="headerlink" title="3.高级配置 advanced.config 修改"></a>3.高级配置 advanced.config 修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% list allowed ciphers</span><br><span class="line">[ </span><br><span class="line"> &#123;ssl, [&#123;versions, [&apos;tlsv1.2&apos;, &apos;tlsv1.1&apos;]&#125;]&#125;,</span><br><span class="line"> &#123;rabbit, [</span><br><span class="line">           &#123;ssl_listeners, [5671]&#125;,</span><br><span class="line">           &#123;ssl_options, [&#123;cacertfile,&quot;/usr/local/etc/rabbitmq/ca/cacert.pem&quot;&#125;,</span><br><span class="line">                          &#123;certfile,  &quot;/usr/local/etc/rabbitmq/ca/cert.pem&quot;&#125;,</span><br><span class="line">                          &#123;keyfile,   &quot;/usr/local/etc/rabbitmq/ca/key.pem&quot;&#125;,</span><br><span class="line">                          &#123;versions, [&apos;tlsv1.2&apos;, &apos;tlsv1.1&apos;]&#125;,</span><br><span class="line">                          %% This list is just an example!</span><br><span class="line">                          %% Not all cipher suites are available on all machines.</span><br><span class="line">                          %% Cipher suite order is important: preferred suites</span><br><span class="line">                          %% should be listed first.</span><br><span class="line">                          %% Different suites have different security and CPU load characteristics.</span><br><span class="line">                          &#123;ciphers,  [                                 &#123;ecdhe_ecdsa,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;ecdhe_rsa,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;ecdhe_ecdsa,aes_256_cbc,sha384,sha384&#125;,</span><br><span class="line">                                      &#123;ecdhe_rsa,aes_256_cbc,sha384,sha384&#125;,</span><br><span class="line">                                      &#123;ecdh_ecdsa,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;ecdh_rsa,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;ecdh_ecdsa,aes_256_cbc,sha384,sha384&#125;,</span><br><span class="line">                                      &#123;ecdh_rsa,aes_256_cbc,sha384,sha384&#125;,</span><br><span class="line">                                      &#123;dhe_rsa,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;dhe_dss,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;dhe_rsa,aes_256_cbc,sha256&#125;,</span><br><span class="line">                                      &#123;dhe_dss,aes_256_cbc,sha256&#125;,</span><br><span class="line">                                      &#123;rsa,aes_256_gcm,null,sha384&#125;,</span><br><span class="line">                                      &#123;rsa,aes_256_cbc,sha256&#125;,</span><br><span class="line">                                      &#123;ecdhe_ecdsa,aes_128_gcm,null,sha256&#125;,</span><br><span class="line">                                      &#123;ecdhe_rsa,aes_128_gcm,null,sha256&#125;,</span><br><span class="line">                                      &#123;ecdhe_ecdsa,aes_128_cbc,sha256,sha256&#125;,</span><br><span class="line">                                      &#123;ecdhe_rsa,aes_128_cbc,sha256,sha256&#125;,</span><br><span class="line">                                      &#123;ecdh_ecdsa,aes_128_gcm,null,sha256&#125;,</span><br><span class="line">                                      &#123;ecdh_rsa,aes_128_gcm,null,sha256&#125;,</span><br><span class="line">                                      &#123;ecdh_ecdsa,aes_128_cbc,sha256,sha256&#125;,</span><br><span class="line">                                      &#123;ecdh_rsa,aes_128_cbc,sha256,sha256&#125;,</span><br><span class="line">                                      &#123;dhe_rsa,aes_128_gcm,null,sha256&#125;,</span><br><span class="line">                                      &#123;dhe_dss,aes_128_gcm,null,sha256&#125;,</span><br><span class="line">                                      &#123;dhe_rsa,aes_128_cbc,sha256&#125;,</span><br><span class="line">                                      &#123;ecdh_rsa,aes_128_gcm,null,sha256&#125;</span><br><span class="line">                                     ]&#125;,</span><br><span class="line">                            &#123;fail_if_no_peer_cert,true&#125;</span><br><span class="line">                         ]&#125;</span><br><span class="line">          ]&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h2 id="三、配置-Java-客户端"><a href="#三、配置-Java-客户端" class="headerlink" title="三、配置 Java 客户端"></a>三、配置 Java 客户端</h2><p>使用JDK自带的keytool工具，可以导入秘钥，进行证书管理。在Java的代码中，通过实例化 <code>Trust Manager</code>实现客户端的认证。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -alias server1 -file /path/to/server/certificate.pem -keystore /path/to/rabbitstore</span><br></pre></td></tr></table></figure><p>上面的命令将导入<code>server/certificate.pem</code>到<code>rabbitstore</code>，并且与<code>server1</code>关联。keytool在确认证书是否被信任的过程会要求设置密码保护。</p><p>下面展示了Java如何使用<code>Key Manager</code>和<code>Trust Manager</code>进行客户端认证。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.security.KeyStore;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.KeyManagerFactory;</span><br><span class="line">import javax.net.ssl.SSLContext;</span><br><span class="line">import javax.net.ssl.TrustManagerFactory;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import com.rabbitmq.client.GetResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Example2 &#123;</span><br><span class="line">    </span><br><span class="line">     public static void main(String[] args) throws Exception</span><br><span class="line">     &#123;</span><br><span class="line">       char[] keyPassphrase = &quot;MySecretPassword&quot;.toCharArray();</span><br><span class="line">       KeyStore ks = KeyStore.getInstance(&quot;PKCS12&quot;);</span><br><span class="line">       </span><br><span class="line">       ks.load(new FileInputStream(Class.class.getResource(&quot;/&quot;).getPath() + &quot;keycert.p12&quot;), keyPassphrase);</span><br><span class="line"></span><br><span class="line">       KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">       kmf.init(ks, keyPassphrase);</span><br><span class="line"></span><br><span class="line">       char[] trustPassphrase = &quot;rabbitstore&quot;.toCharArray();</span><br><span class="line">       KeyStore tks = KeyStore.getInstance(&quot;JKS&quot;);</span><br><span class="line">       tks.load(new FileInputStream(Class.class.getResource(&quot;/&quot;).getPath() + &quot;rabbitstore&quot;), trustPassphrase);</span><br><span class="line"></span><br><span class="line">       TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">       tmf.init(tks);</span><br><span class="line"></span><br><span class="line">       SSLContext c = SSLContext.getInstance(&quot;TLSv1.1&quot;);</span><br><span class="line">       c.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);</span><br><span class="line"></span><br><span class="line">       ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">       factory.setHost(&quot;&quot;);</span><br><span class="line">       factory.setPort(5671);</span><br><span class="line">       </span><br><span class="line">       factory.setUsername(&quot;&quot;);</span><br><span class="line">       factory.setPassword(&quot;&quot;);</span><br><span class="line">       </span><br><span class="line">       factory.useSslProtocol(c);</span><br><span class="line"></span><br><span class="line">       Connection conn = factory.newConnection(); </span><br><span class="line">       Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">       channel.queueDeclare(&quot;rabbitmq-java-test&quot;, false, true, true, null);</span><br><span class="line">       channel.basicPublish(&quot;&quot;, &quot;rabbitmq-java-test&quot;, null, &quot;Hello, World&quot;.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       GetResponse chResponse = channel.basicGet(&quot;rabbitmq-java-test&quot;, false);</span><br><span class="line">       if(chResponse == null) &#123;</span><br><span class="line">           System.out.println(&quot;No message retrieved&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           byte[] body = chResponse.getBody();</span><br><span class="line">           System.out.println(&quot;Recieved: &quot; + new String(body));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       channel.close();</span><br><span class="line">       conn.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、配置有效性检查"><a href="#四、配置有效性检查" class="headerlink" title="四、配置有效性检查"></a>四、配置有效性检查</h2><h4 id="1-证书有效性校验"><a href="#1-证书有效性校验" class="headerlink" title="1.证书有效性校验"></a>1.证书有效性校验</h4><p>打开一个终端，输入以下命令启动服务端：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl s_server -accept 8443 -cert server/cert.pem -key server/key.pem -CAfile testca/cacert.pem</span><br></pre></td></tr></table></figure><p>在另外一个终端，输入以下命令启动客户端：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect localhost:8443 -cert client/cert.pem -key client/key.pem -CAfile testca/cacert.pem</span><br></pre></td></tr></table></figure><p>如果生产的证书是有效的，将会在客户端返回连接成功的消息，结尾如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Verify return code: 0 (ok)</span><br></pre></td></tr></table></figure><h4 id="2-验证RabbitMQ配置有效性"><a href="#2-验证RabbitMQ配置有效性" class="headerlink" title="2.验证RabbitMQ配置有效性"></a>2.验证RabbitMQ配置有效性</h4><p><strong>查看日志</strong></p><p>在RabbitMQ启动的控制台，可以看到日志的位置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Logs: /usr/local/var/log/rabbitmq/rabbit@localhost.log</span><br><span class="line">      /usr/local/var/log/rabbitmq/rabbit@localhost_upgrade.log</span><br></pre></td></tr></table></figure><p>查看日志的内容，可以看到如下内容，说明<code>TLS</code>配置已经生效：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">started SSL Listener on [::]:5671</span><br></pre></td></tr></table></figure><p><strong>手动建立openssl连接</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect localhost:5671 -cert client/cert.pem -key client/key.pem -CAfile testca/cacert.pem</span><br></pre></td></tr></table></figure><p>如果连接成功，会看到和前面<code>8443</code>端口连接相同的结束信息，并且会在<code>RabbitMQ</code>的日志中查看到如下消息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accepting AMQP connection &lt;0.223.0&gt; (127.0.0.1:58954 -&gt; 127.0.0.1:5671)</span><br></pre></td></tr></table></figure><h2 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h2><h4 id="1-客户端证书密码错误"><a href="#1-客户端证书密码错误" class="headerlink" title="1.客户端证书密码错误"></a>1.客户端证书密码错误</h4><p>如果在<code>Java</code>客户端中，导入<code>keycert.p12</code>证书的密码设置错误，控制台会返回如下异常。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.io.IOException: failed to decrypt safe contents entry: javax.crypto.BadPaddingException: Given final block not properly padded</span><br></pre></td></tr></table></figure><h4 id="2-客户端和服务器的加密套协商失败"><a href="#2-客户端和服务器的加密套协商失败" class="headerlink" title="2.客户端和服务器的加密套协商失败"></a>2.客户端和服务器的加密套协商失败</h4><p>使用<code>openssl</code>或者<code>Java</code>客户端进行远程连接时，会使用<code>openssl</code>或者<code>JDK</code>的加密套，但是，<code>RabbitMQ</code>的服务端中，默认的加密套（cipher suite）不一定会有与之一致的加密算法，这将在<strong>握手</strong>阶段就发生协商加密套失败，客户端的错误返回如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: Received fatal alert: insufficient_security</span><br></pre></td></tr></table></figure><p>查看<code>RabbitMQ</code>的日志，可以看到详细的错误如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TLS server: In state hello at tls_handshake.erl:197 generated SERVER ALERT: Fatal - Insufficient Security - no_suitable_ciphers</span><br></pre></td></tr></table></figure><p>可以知道是握手阶段的加密套协商失败，因此，可以通过<code>wireshark</code>抓包，查看客户端发出请求所包含的加密套。我的Java客户端加密套如下所示：</p><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/cipher-suite.png?imageView2/2/w/1536"><p>从图中，可以看到<code>OpenSSL</code>定义的加密套名称，我选择其中的一个，在github上找到对应的<code>Erlang</code>名称，添加到<code>RabbitMQ</code>的<code>advance.config</code>中，重启服务之后，就能够完成握手了。</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><table><thead><tr><th>OpenSSL</th><th style="text-align:center">IANA</th><th style="text-align:center">Erlang</th></tr></thead><tbody><tr><td>TLS_PSK_WITH_NULL_SHA</td><td style="text-align:center">PSK-NULL-SHA</td><td style="text-align:center">{psk, null, sha, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_NULL_SHA</td><td style="text-align:center">DHE-PSK-NULL-SHA</td><td style="text-align:center">{dhe_psk, null, sha, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_NULL_SHA</td><td style="text-align:center">RSA-PSK-NULL-SHA</td><td style="text-align:center">{rsa_psk, null, sha, default_prf}</td></tr><tr><td>TLS_RSA_WITH_AES_128_CBC_SHA</td><td style="text-align:center">AES128-SHA</td><td style="text-align:center">{rsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</td><td style="text-align:center">DHE-DSS-AES128-SHA</td><td style="text-align:center">{dhe_dss, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td><td style="text-align:center">DHE-RSA-AES128-SHA</td><td style="text-align:center">{dhe_rsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_DH_anon_WITH_AES_128_CBC_SHA</td><td style="text-align:center">ADH-AES128-SHA</td><td style="text-align:center">{dh_anon, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_RSA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">AES256-SHA</td><td style="text-align:center">{rsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</td><td style="text-align:center">DHE-DSS-AES256-SHA</td><td style="text-align:center">{dhe_dss, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">DHE-RSA-AES256-SHA</td><td style="text-align:center">{dhe_rsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_DH_anon_WITH_AES_256_CBC_SHA</td><td style="text-align:center">ADH-AES256-SHA</td><td style="text-align:center">{dh_anon, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_RSA_WITH_AES_128_CBC_SHA256</td><td style="text-align:center">AES128-SHA256</td><td style="text-align:center">{rsa, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_RSA_WITH_AES_256_CBC_SHA256</td><td style="text-align:center">AES256-SHA256</td><td style="text-align:center">{rsa, aes_256_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</td><td style="text-align:center">DHE-DSS-AES128-SHA256</td><td style="text-align:center">{dhe_dss, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td><td style="text-align:center">DHE-RSA-AES128-SHA256</td><td style="text-align:center">{dhe_rsa, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</td><td style="text-align:center">DHE-DSS-AES256-SHA256</td><td style="text-align:center">{dhe_dss, aes_256_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</td><td style="text-align:center">DHE-RSA-AES256-SHA256</td><td style="text-align:center">{dhe_rsa, aes_256_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DH_anon_WITH_AES_128_CBC_SHA256</td><td style="text-align:center">ADH-AES128-SHA256</td><td style="text-align:center">{dh_anon, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DH_anon_WITH_AES_256_CBC_SHA256</td><td style="text-align:center">ADH-AES256-SHA256</td><td style="text-align:center">{dh_anon, aes_256_cbc, sha256, default_prf}</td></tr><tr><td>TLS_PSK_WITH_RC4_128_SHA</td><td style="text-align:center">PSK-RC4-SHA</td><td style="text-align:center">{psk, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_PSK_WITH_3DES_EDE_CBC_SHA</td><td style="text-align:center">PSK-3DES-EDE-CBC-SHA</td><td style="text-align:center">{psk, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_PSK_WITH_AES_128_CBC_SHA</td><td style="text-align:center">PSK-AES128-CBC-SHA</td><td style="text-align:center">{psk, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_PSK_WITH_AES_256_CBC_SHA</td><td style="text-align:center">PSK-AES256-CBC-SHA</td><td style="text-align:center">{psk, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_RC4_128_SHA</td><td style="text-align:center">DHE-PSK-RC4-SHA    {dhe_psk, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA</td><td style="text-align:center">DHE-PSK-3DES-EDE-CBC-SHA    {dhe_psk, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_AES_128_CBC_SHA</td><td style="text-align:center">DHE-PSK-AES128-CBC-SHA    {dhe_psk, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_AES_256_CBC_SHA</td><td style="text-align:center">DHE-PSK-AES256-CBC-SHA    {dhe_psk, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_RC4_128_SHA</td><td style="text-align:center">RSA-PSK-RC4-SHA</td><td style="text-align:center">{rsa_psk, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA</td><td style="text-align:center">RSA-PSK-3DES-EDE-CBC-SHA</td><td style="text-align:center"></td><td>{rsa_psk, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_AES_128_CBC_SHA</td><td style="text-align:center">RSA-PSK-AES128-CBC-SHA</td><td style="text-align:center">{rsa_psk, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_AES_256_CBC_SHA</td><td style="text-align:center">RSA-PSK-AES256-CBC-SHA</td><td style="text-align:center">{rsa_psk, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_RSA_WITH_AES_128_GCM_SHA256    AES128-GCM-SHA256</td><td style="text-align:center">{rsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_RSA_WITH_AES_256_GCM_SHA384    AES256-GCM-SHA384</td><td style="text-align:center">{rsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256    DHE-RSA-AES128-GCM-SHA256</td><td style="text-align:center">{dhe_rsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384    DHE-RSA-AES256-GCM-SHA384</td><td style="text-align:center">{dhe_rsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_DH_RSA_WITH_AES_128_GCM_SHA256    DH-RSA-AES128-GCM-SHA256</td><td style="text-align:center">{dh_rsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_DH_RSA_WITH_AES_256_GCM_SHA384    DH-RSA-AES256-GCM-SHA384</td><td style="text-align:center">{dh_rsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_DHE_DSS_WITH_AES_128_GCM_SHA256    DHE-DSS-AES128-GCM-SHA256</td><td style="text-align:center">{dhe_dss, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_DHE_DSS_WITH_AES_256_GCM_SHA384    DHE-DSS-AES256-GCM-SHA384</td><td style="text-align:center">{dhe_dss, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_DH_DSS_WITH_AES_128_GCM_SHA256    DH-DSS-AES128-GCM-SHA256</td><td style="text-align:center">{dh_dss, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_DH_DSS_WITH_AES_256_GCM_SHA384    DH-DSS-AES256-GCM-SHA384</td><td style="text-align:center">{dh_dss, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_DH_anon_WITH_AES_128_GCM_SHA256    ADH-AES128-GCM-SHA256</td><td style="text-align:center">{dh_anon, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_DH_anon_WITH_AES_256_GCM_SHA384    ADH-AES256-GCM-SHA384</td><td style="text-align:center">{dh_anon, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_PSK_WITH_AES_128_GCM_SHA256    PSK-AES128-GCM-SHA256</td><td style="text-align:center">{psk, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_PSK_WITH_AES_256_GCM_SHA384    PSK-AES256-GCM-SHA384</td><td style="text-align:center">{psk, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_DHE_PSK_WITH_AES_128_GCM_SHA256    DHE-PSK-AES128-GCM-SHA256</td><td style="text-align:center">{dhe_psk, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_DHE_PSK_WITH_AES_256_GCM_SHA384    DHE-PSK-AES256-GCM-SHA384</td><td style="text-align:center">{dhe_psk, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_RSA_PSK_WITH_AES_128_GCM_SHA256    RSA-PSK-AES128-GCM-SHA256</td><td style="text-align:center">{rsa_psk, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_RSA_PSK_WITH_AES_256_GCM_SHA384    RSA-PSK-AES256-GCM-SHA384</td><td style="text-align:center">{rsa_psk, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_PSK_WITH_AES_128_CBC_SHA256    PSK-AES128-CBC-SHA256</td><td style="text-align:center">{psk, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_PSK_WITH_AES_256_CBC_SHA384    PSK-AES256-CBC-SHA384</td><td style="text-align:center">{psk, aes_256_cbc, sha384, default_prf}</td></tr><tr><td>TLS_PSK_WITH_NULL_SHA256    PSK-NULL-SHA256</td><td style="text-align:center">{psk, null, sha256, default_prf}</td></tr><tr><td>TLS_PSK_WITH_NULL_SHA384    PSK-NULL-SHA384</td><td style="text-align:center">{psk, null, sha384, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_AES_128_CBC_SHA256    DHE-PSK-AES128-CBC-SHA256</td><td style="text-align:center">{dhe_psk, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_AES_256_CBC_SHA384</td><td style="text-align:center">DHE-PSK-AES256-CBC-SHA384</td><td style="text-align:center">{dhe_psk, aes_256_cbc, sha384, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_NULL_SHA256</td><td style="text-align:center">DHE-PSK-NULL-SHA256</td><td style="text-align:center">{dhe_psk, null, sha256, default_prf}</td></tr><tr><td>TLS_DHE_PSK_WITH_NULL_SHA384</td><td style="text-align:center">DHE-PSK-NULL-SHA384</td><td style="text-align:center">{dhe_psk, null, sha384, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_AES_128_CBC_SHA256</td><td style="text-align:center">RSA-PSK-AES128-CBC-SHA256</td><td style="text-align:center">{rsa_psk, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_AES_256_CBC_SHA384</td><td style="text-align:center">RSA-PSK-AES256-CBC-SHA384</td><td style="text-align:center">{rsa_psk, aes_256_cbc, sha384, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_NULL_SHA256</td><td style="text-align:center">RSA-PSK-NULL-SHA256</td><td style="text-align:center">{rsa_psk, null, sha256, default_prf}</td></tr><tr><td>TLS_RSA_PSK_WITH_NULL_SHA384</td><td style="text-align:center">RSA-PSK-NULL-SHA384</td><td style="text-align:center">{rsa_psk, null, sha384, default_prf}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_NULL_SHA</td><td style="text-align:center">ECDH-ECDSA-NULL-SHA</td><td style="text-align:center">{ecdh_ecdsa, null, sha, default_prf}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</td><td style="text-align:center">ECDH-ECDSA-RC4-SHA</td><td style="text-align:center">{ecdh_ecdsa, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</td><td style="text-align:center">ECDH-ECDSA-DES-CBC3-SHA</td><td style="text-align:center">{ecdh_ecdsa, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</td><td style="text-align:center">ECDH-ECDSA-AES128-SHA</td><td style="text-align:center">{ecdh_ecdsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">ECDH-ECDSA-AES256-SHA</td><td style="text-align:center">{ecdh_ecdsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_NULL_SHA</td><td style="text-align:center">ECDHE-ECDSA-NULL-SHA</td><td style="text-align:center">{ecdhe_ecdsa, null, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</td><td style="text-align:center">ECDHE-ECDSA-RC4-SHA</td><td style="text-align:center">{ecdhe_ecdsa, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</td><td style="text-align:center">ECDHE-ECDSA-DES-CBC3-SHA</td><td style="text-align:center">{ecdhe_ecdsa, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</td><td style="text-align:center">ECDHE-ECDSA-AES128-SHA</td><td style="text-align:center">{ecdhe_ecdsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">ECDHE-ECDSA-AES256-SHA</td><td style="text-align:center">{ecdhe_ecdsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDH_RSA_WITH_NULL_SHA</td><td style="text-align:center">ECDH-RSA-NULL-SHA</td><td style="text-align:center">{ecdh_rsa, null, sha, default_prf}</td></tr><tr><td>TLS_ECDH_RSA_WITH_RC4_128_SHA</td><td style="text-align:center">ECDH-RSA-RC4-SHA</td><td style="text-align:center">{ecdh_rsa, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</td><td style="text-align:center">ECDH-RSA-DES-CBC3-SHA</td><td style="text-align:center">{ecdh_rsa, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</td><td style="text-align:center">ECDH-RSA-AES128-SHA</td><td style="text-align:center">{ecdh_rsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">ECDH-RSA-AES256-SHA</td><td style="text-align:center">{ecdh_rsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_NULL_SHA</td><td style="text-align:center">ECDHE-RSA-NULL-SHA</td><td style="text-align:center">{ecdhe_rsa, null, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_RC4_128_SHA</td><td style="text-align:center">ECDHE-RSA-RC4-SHA</td><td style="text-align:center">{ecdhe_rsa, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    ECDHE-RSA-DES-CBC3-SHA    {ecdhe_rsa, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA    ECDHE-RSA-AES128-SHA    {ecdhe_rsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA    ECDHE-RSA-AES256-SHA    {ecdhe_rsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDH_anon_WITH_NULL_SHA    AECDH-NULL-SHA    {ecdh_anon, null, sha, default_prf}</td></tr><tr><td>TLS_ECDH_anon_WITH_RC4_128_SHA    AECDH-RC4-SHA    {ecdh_anon, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA    AECDH-DES-CBC3-SHA    {ecdh_anon, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_ECDH_anon_WITH_AES_128_CBC_SHA    AECDH-AES128-SHA    {ecdh_anon, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDH_anon_WITH_AES_256_CBC_SHA    AECDH-AES256-SHA    {ecdh_anon, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA    SRP-3DES-EDE-CBC-SHA    {srp_anon, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA    SRP-RSA-3DES-EDE-CBC-SHA    {srp_rsa, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA    SRP-DSS-3DES-EDE-CBC-SHA    {srp_dss, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_WITH_AES_128_CBC_SHA    SRP-AES-128-CBC-SHA    {srp_anon, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA    SRP-RSA-AES-128-CBC-SHA</td><td style="text-align:center">{srp_rsa, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA    SRP-DSS-AES-128-CBC-SHA</td><td style="text-align:center">{srp_dss, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">SRP-AES-256-CBC-SHA</td><td style="text-align:center">{srp_anon, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA</td><td style="text-align:center">SRP-RSA-AES-256-CBC-SHA</td><td style="text-align:center">{srp_rsa, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA</td><td style="text-align:center">SRP-DSS-AES-256-CBC-SHA</td><td style="text-align:center">{srp_dss, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</td><td style="text-align:center">ECDHE-ECDSA-AES128-SHA256</td><td style="text-align:center">{ecdhe_ecdsa, aes_128_cbc, sha256, sha256}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384    ECDHE-ECDSA-AES256-SHA384    {ecdhe_ecdsa, aes_256_cbc, sha384, sha384}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256    ECDH-ECDSA-AES128-SHA256    {ecdh_ecdsa, aes_128_cbc, sha256, sha256}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384    ECDH-ECDSA-AES256-SHA384    {ecdh_ecdsa, aes_256_cbc, sha384, sha384}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256    ECDHE-RSA-AES128-SHA256    {ecdhe_rsa, aes_128_cbc, sha256, sha256}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384    ECDHE-RSA-AES256-SHA384    {ecdhe_rsa, aes_256_cbc, sha384, sha384}</td></tr><tr><td>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256    ECDH-RSA-AES128-SHA256    {ecdh_rsa, aes_128_cbc, sha256, sha256}</td></tr><tr><td>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384    ECDH-RSA-AES256-SHA384    {ecdh_rsa, aes_256_cbc, sha384, sha384}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256    ECDHE-ECDSA-AES128-GCM-SHA256    {ecdhe_ecdsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384    ECDHE-ECDSA-AES256-GCM-SHA384    {ecdhe_ecdsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</td><td style="text-align:center">ECDH-ECDSA-AES128-GCM-SHA256</td><td style="text-align:center">{ecdh_ecdsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</td><td style="text-align:center">ECDH-ECDSA-AES256-GCM-SHA384</td><td style="text-align:center">{ecdh_ecdsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td><td style="text-align:center">ECDHE-RSA-AES128-GCM-SHA256</td><td style="text-align:center">{ecdhe_rsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</td><td style="text-align:center">ECDHE-RSA-AES256-GCM-SHA384</td><td style="text-align:center">{ecdhe_rsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256    ECDH-RSA-AES128-GCM-SHA256</td><td style="text-align:center">{ecdh_rsa, aes_128_gcm, null, sha256}</td></tr><tr><td>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384    ECDH-RSA-AES256-GCM-SHA384</td><td style="text-align:center">{ecdh_rsa, aes_256_gcm, null, sha384}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_RC4_128_SHA    ECDHE-PSK-RC4-SHA</td><td style="text-align:center">{ecdhe_psk, rc4_128, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA    ECDHE-PSK-3DES-EDE-CBC-SHA    {ecdhe_psk, ‘3des_ede_cbc’, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA    ECDHE-PSK-AES128-CBC-SHA    {ecdhe_psk, aes_128_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA    ECDHE-PSK-AES256-CBC-SHA    {ecdhe_psk, aes_256_cbc, sha, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256    ECDHE-PSK-AES128-CBC-SHA256    {ecdhe_psk, aes_128_cbc, sha256, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384</td><td style="text-align:center">ECDHE-PSK-AES256-CBC-SHA384</td><td style="text-align:center">{ecdhe_psk, aes_256_cbc, sha384, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_NULL_SHA256</td><td style="text-align:center">ECDHE-PSK-NULL-SHA256</td><td style="text-align:center">{ecdhe_psk, null, sha256, default_prf}</td></tr><tr><td>TLS_ECDHE_PSK_WITH_NULL_SHA384</td><td style="text-align:center">ECDHE-PSK-NULL-SHA384</td><td style="text-align:center">{ecdhe_psk, null, sha384, default_prf}</td></tr><tr><td>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td><td style="text-align:center">ECDHE-RSA-CHACHA20-POLY1305</td><td style="text-align:center">{ecdhe_rsa, chacha20_poly1305, null, sha256}</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</td><td style="text-align:center">ECDHE-ECDSA-CHACHA20-POLY1305</td><td style="text-align:center">{ecdhe_ecdsa, chacha20_poly1305, null, sha256}</td></tr><tr><td>TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td><td style="text-align:center">DHE-RSA-CHACHA20-POLY1305</td><td style="text-align:center">{dhe_rsa, chacha20_poly1305, null, sha256}</td></tr></tbody></table><p>映射表：<br><a href="https://github.com/rabbitmq/rabbitmq-website/issues/453" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-website/issues/453</a><br>加密套概念：<br><a href="https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/" target="_blank" rel="noopener">https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/</a><br>加密协议：<br><a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4" target="_blank" rel="noopener">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4</a><br>openssl配置说明：<br><a href="http://www.jinbuguo.com/linux/openssl_install.html" target="_blank" rel="noopener">http://www.jinbuguo.com/linux/openssl_install.html</a></p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JAVA:正则表达式用法</title>
      <link href="/posts/5ddc6624/"/>
      <url>/posts/5ddc6624/</url>
      <content type="html"><![CDATA[<h2 id="java的regex库"><a href="#java的regex库" class="headerlink" title="java的regex库"></a>java的regex库</h2><p>java里预留了一个regex库，方便于我们在java里操作正则表达式，或者用它来匹配字符串。</p><p>其中比较常用的就是 Pattern 和 Matcher ,pattern是一个编译好的正则表达式，而Matcher是一个正则表达式适配器，Matcher的功能很强大，所以我们一般用pattern 来获取一个Matcher对象，然后用Matcher来操作正则表达式。先看一下这两个类的用法吧.</p><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>创建<code>pattern</code>的对象是很简单的，但是由于<code>pattern</code>的构造方法是用<code>private</code>声明的，所以我们仅能通过工厂模式的<code>compile</code>方法来返回一个<code>Pattern</code>的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"[abc]"</span>);</span><br></pre></td></tr></table></figure><p>compile可以接收一个正则表达式作为参数。</p><p>接下来我们创建一个<code>Matcher</code>对象。<code>Matcher</code>的构造方法也是一个<code>private</code>方法，但是我们可以通过<code>Pattern</code>的<code>Matcher</code>方法来返回一个<code>Matcher</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Matcher matcher = pattern.matcher(<span class="string">"hello abc"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里<code>matcher</code>可以接收一个字符串作为参数，准确的说这里所接收的参数类型是<code>CharSequences</code>接口类型的参数，但是<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>，还有<code>CharBuffer</code>都实现了<code>CharSequence</code>接口，因此我们向里面传入这四种任何我们需要的参数。</p><p>与此同时<code>Pattern</code>还提供了一个<code>matches</code>静态方法，它允许我们传入一个<code>String</code>类型的正则表达式和一个<code>String</code>类型的需要匹配的字符串，并返回一个<code>boolean</code>类型的值，这个方法的好处在于我们可以不用创建<code>pattern</code>对象和<code>matcher</code>对象就可以知道所传入的正则表达式能不能匹配所传入的字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> bool = Pattern.matches(<span class="string">"\\w+"</span>,<span class="string">"hello abc"</span>);</span><br></pre></td></tr></table></figure><h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><p>说到<code>Matcher</code>，这个东西就很强大了，我们比较常用的方法有:</p><p><strong>find();</strong></p><p><strong>group();</strong></p><p>（1）先来说一下<code>find()</code>和<code>group()</code>这两个方法。</p><ul><li><code>find</code>有点像一个迭代器，它能通过正则表达式向前迭代。下来看一个例子</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"\\w+"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"hello abc bbc cbc ccc"</span>);</span><br><span class="line">        <span class="comment">//find向前迭代</span></span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看看 jdk 给出的 api 怎么定义<code>find</code>的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以知道<code>find</code>返回的是一个<code>boolean</code>值，当前方没有内容的时候，<code>find</code>会返回<code>false</code>，所以我们这里可以直接用<code>while</code>来写，这句代码打印出的内容是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">abc</span><br><span class="line">bbc</span><br><span class="line">cbc</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p>可以看到其实我们的正则表达式”\w+”只匹配到了第一个单词hello ，但是因为find迭代的关系，把后面的单词全部都打印出来了，参照的正是我们给出的正则表达式。</p><p>（2）<code>group</code>: 说到<code>find</code>就不得不说<code>group</code>。<br>下面看个式子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a(b)(c(d)))</span><br></pre></td></tr></table></figure><ul><li>这里的话我们把整个式子称为第0组,</li><li>第一组是 a(b)(c(d))</li><li>第二组是 子式 b 和 子式c(d)</li><li>第三组是 d</li></ul><p>看一下几个<code>group</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回此匹配器模式中的捕获组数，这个方法也就是返回所匹配的字符串的组数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"(\\w+)\\d+"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"hello123 abc bbc cbc ccc"</span>);</span><br><span class="line">        matcher.find();</span><br><span class="line">        System.out.println(matcher.groupCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里匹配到的是<code>hello123</code>， 当然不加()也能得到，这里只是为了方便演示。<br>打印出来的数值是1，这是因为我们只有一个组</p><p>那<code>group()</code>呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">group</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回由以前匹配操作所匹配的输入子序列。</p><p>也就是说<code>group</code>是返回所匹配到的<code>第0组</code>的值，返回值是一个<code>String</code>。这也能解释我们刚刚用<code>find</code>进行迭代的那个例子了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"\\w+"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"hello abc bbc cbc ccc"</span>);</span><br><span class="line">        <span class="comment">//find向前迭代</span></span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有分组所以直接将匹配到的<code>String</code>打印出来，其实也就是<code>第0组</code>。</p><p>另外，<code>group</code>还有个重载的方法，可以接收一个<code>int</code>类型的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">group</span><span class="params">(<span class="keyword">int</span> group)</span></span></span><br></pre></td></tr></table></figure><p>返回在以前匹配操作期间由给定组捕获的输入子序列。<br>传入的参数正是组数.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"(\\w+)\\s\\d+"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"hello 123 abc bbc cbc ccc"</span>);</span><br><span class="line">        matcher.find();</span><br><span class="line">        System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出来的结果正在我们的意料之中是<code>hello</code>。</p><p>除此之外还有两个可以返回匹配当前字符串的索引的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">end</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>start</code>是返回匹配成功的子串的第一个字母的索引，而<code>end</code>是返回子串最后一个索引的位置<code>+1</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String input = <span class="string">"hello abc BBc Cbc ccc"</span>;</span><br><span class="line">Matcher matcher = Pattern.compile(<span class="string">"[A-Z][A-Z]\\w"</span>).matcher(input);</span><br><span class="line">matcher.find();</span><br><span class="line">System.out.println(input.charAt(matcher.start()));</span><br></pre></td></tr></table></figure><p>这里打印出来的值是B。但是如果我们换成end就不一样了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(input.charAt(matcher.end()));</span><br></pre></td></tr></table></figure><p>这里打印出来的值却是<code>&quot; &quot;</code>是一个空字符,也就是c的索引加了1，所以我们这里只需稍作修改便可以打印出<code>c</code>了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(input.charAt(matcher.end()-1));</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> regex </tag>
            
            <tag> pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMQ:配置远程访问</title>
      <link href="/posts/e4d74468/"/>
      <url>/posts/e4d74468/</url>
      <content type="html"><![CDATA[<h2 id="开启WEB管理"><a href="#开启WEB管理" class="headerlink" title="开启WEB管理"></a>开启WEB管理</h2><p>如果只从命令行操作RabbitMQ，多少有点不方便。幸好RabbitMQ自带了web管理界面，只需要启动插件便可以使用。控制台输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>响应如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@vhost05...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line"></span><br><span class="line">started 3 plugins.</span><br></pre></td></tr></table></figure><p>然后通过浏览器访问 url: <code>http://ip:15672</code></p><h2 id="添加用户并授权"><a href="#添加用户并授权" class="headerlink" title="添加用户并授权"></a>添加用户并授权</h2><p>默认的guest/guest用户，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user csh csh</span><br><span class="line">rabbitmqctl set_user_tags csh administrator</span><br><span class="line">rabbitmqctl set_permissions -p / csh &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></p><h2 id="查看用户列表"><a href="#查看用户列表" class="headerlink" title="查看用户列表"></a>查看用户列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h2 id="Mac特殊情况"><a href="#Mac特殊情况" class="headerlink" title="Mac特殊情况"></a>Mac特殊情况</h2><p>使用HomeBrew安装rabbitmq，会在<code>/usr/local/etc/</code>的环境变量文件<code>rabbitmq-env.conf</code>中有如下配置,使得rabbitmq只能监听<code>127.0.01</code>进来的连接。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_IP_ADDRESS=127.0.0.1</span><br></pre></td></tr></table></figure><p>注释掉这部分内容后，就可以从其他机器访问连接。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Spring：基本知识</title>
      <link href="/posts/c157b8b0/"/>
      <url>/posts/c157b8b0/</url>
      <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring 是 2003 年兴起的一个轻量级的 Java 开发框架，由 Rod Johnson 创建。它解决了业务逻辑层和其他各层的松耦合问题，并将面向接口的编程思想贯穿整个系统应用。</p><p>简单来说，Spring 是一个分层的 JavaSE/EE Full-Stack（一站式） 轻量级开源框架。为什么说 spring 是分层、一站式、轻量级的框架呢？</p><p>首先看分层。JavaEE 经典的 MVC 三层结构为表现层、业务层、持久层，Web表现层负责页面数据显示、页面跳转调度，例如 JSP/Servlet、SpringMVC；</p><p>Service 业务层负责业务处理、功能逻辑和事务控制，例如 Service、JavaBean、EJB；而持久层Dao则负责数据存取和封装，及与数据库打交道，例如 JDBC、Hibernate、Mybatis。<br><a id="more"></a></p><p>而一站式，则指 Spring 为 JavaEE 的每一层都提供了解决方案，比如：</p><ul><li><p>表现层：Struts1、Struts2、Spring MVC；</p></li><li><p>业务层：IoC 控制反转、AOP 面向切面编程、事务控制；</p></li><li><p>持久层：JdbcTemplate、HibernateTemplate、ORM 框架（对象关系映射）的整合。</p></li></ul><p>至于轻量，则是指从大小与开销两方面而言，Spring都是轻量的。完整的 Spring 框架可以在一个大小只有 1MB 多的 Jar 文件里发布。并且 Spring 所需的处理开销也是微不足道的。</p><p>Spring 的出现解决了 EJB 臃肿、低效、繁琐复杂、脱离现实的情况。而且使用 Spring 编程是非侵入式的。Spring 应用中的对象不依赖于 Spring 的特定类。</p><h2 id="Spring-的体系结构"><a href="#Spring-的体系结构" class="headerlink" title="Spring 的体系结构"></a>Spring 的体系结构</h2><p>Spring 框架是一个分层架构，它包含一系列的功能要素，被分为大约20个模块。这些模块分为 Core Container、Data Access/Integration、Web、AOP、Aspects、Instrumentation 和 Test，如下图所示：</p><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/Spring-arc.png?imageView2/2/w/1536"><p>核心容器（Core Container）包括 Core、Beans、Context、EL 模块。</p><ol><li>Core 和 Beans 模块提供了 Spring 最基础的功能，Core 模块是核心，为其他模块提供支持，包括 Spring 的核心工具类。Beans 是 Spring 管理实体类 Bean 的主要模块，提供 IoC 控制反转和依赖注入 DI。</li></ol><p>控制反转即将控制权由原来的程序员自己管理交给 Spring 来管理，依赖注入就是注入对象实例，有四种方式，即接口注入、setter 方法注入、构造器注入和注解注入。</p><ol start="2"><li><p>Context 上下文模块，主要基于 Core 和 Beans 模块，Context 模块的 Context 包继承了 Beans 包的功能，还增加了国际化（I18N）、事件传播等，Context 上下文模块，还包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</p></li><li><p>Expression Language，表达式语言模块，又称 SpEL，提供了在运行期间查询和操作对象图的强大能力。包含五个主要特性：（1）使用 Bean 的 ID 引用 Bean；（2）调用方法和访问对象的属性；（3）对值进行算术，关系和逻辑运算；（4）正则表达式匹配；（5）集合操作。</p></li></ol><h2 id="Spring-的三大核心"><a href="#Spring-的三大核心" class="headerlink" title="Spring 的三大核心"></a>Spring 的三大核心</h2><p>这三大核心分别为 IOC（Inverse of Control 控制反转）、DI（Dependency Injection，依赖注入）和AOP（Aspect Oriented Programming 面向切面编程）。</p><h4 id="1-IOC（Inverse-of-Control-控制反转）"><a href="#1-IOC（Inverse-of-Control-控制反转）" class="headerlink" title="1. IOC（Inverse of Control 控制反转）"></a>1. IOC（Inverse of Control 控制反转）</h4><p>IOC，即将对象创建权利交给 Spring 工厂进行管理。比如说</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content content = <span class="keyword">new</span> Content();</span><br></pre></td></tr></table></figure><p>现在，可以这样写:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content content = ContentFactory.getContent();</span><br></pre></td></tr></table></figure><h4 id="2-DI（Dependency-Injection，依赖注入）"><a href="#2-DI（Dependency-Injection，依赖注入）" class="headerlink" title="2. DI（Dependency Injection，依赖注入）"></a>2. DI（Dependency Injection，依赖注入）</h4><p>DI 是指在 Spring 框架创建 Bean 对象时，动态地将依赖对象注入到 Bean 组件。简单的说，就是将另外一个 Bean 对象动态地注入到另一个 Bean 中。</p><p>DI 的做法是：由 Spring 容器创建 Service、Dao 对象，并且通过注解或配置将 Dao 传入 Servcie，那么 Service 对象就包含了 Dao 对象的引用。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowire</span> <span class="comment">//通过注解注入对象</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-AOP（Aspect-Oriented-Programming-面向切面编程）"><a href="#3-AOP（Aspect-Oriented-Programming-面向切面编程）" class="headerlink" title="3. AOP（Aspect Oriented Programming 面向切面编程）"></a>3. AOP（Aspect Oriented Programming 面向切面编程）</h4><p>AOP 采取横向抽取机制，取代了传统纵向继承体系重复性代码的编写方式（例如性能监视、事务管理、安全检查、缓存、日志记录等）。</p><p>AOP 基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强。例如可以在插入 User 对象之前进行打印日志，请看下面的代码示例。</p><p>UserService.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置增强类 PrintLogBefore.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置增强代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintLogBefore</span> <span class="keyword">implements</span> <span class="title">MehtodBeforeAdvice</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getLogger(PrintLogBefore.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] arguments, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">log.info(<span class="string">"在插入User之前执行的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配置切入点：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"printBefore"</span> <span class="attr">class</span>=<span class="string">"com.example.PrintLogBefore"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(public void add(com.example.entity.User))"</span> <span class="attr">id</span>=<span class="string">"pointcut /&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;aop:advisor advice-ref="</span><span class="attr">printBefore</span>" <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样在调用 add(User user) 方法之前就会打印如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“在插入User之前执行的方法”</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java:并发编程lock</title>
      <link href="/posts/9b7d34c3/"/>
      <url>/posts/9b7d34c3/</url>
      <content type="html"><![CDATA[<p>从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</p><p>但是，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西</p><p>原文链接：<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></p><h2 id="一-synchronized的缺陷"><a href="#一-synchronized的缺陷" class="headerlink" title="一.synchronized的缺陷"></a>一.synchronized的缺陷</h2><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>　　在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><p>　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p>　　2）线程执行发生异常，此时JVM会让线程自动释放锁。</p><p>　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p><a id="more"></a><p>　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>　　再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p><p>　　因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>　　另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>　　总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><p>　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p><p>　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。　　</p><h2 id="java-util-concurrent-locks包下常用的类"><a href="#java-util-concurrent-locks包下常用的类" class="headerlink" title="java.util.concurrent.locks包下常用的类"></a>java.util.concurrent.locks包下常用的类</h2><p>下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。</p><h4 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1.Lock"></a>1.Lock</h4><p>　　首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。</p><p>　　在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？</p><p>　　首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>　　由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：<br>　　<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    //处理任务</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();   //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><p>　　所以，一般情况下通过tryLock来获取锁时是这样使用的：<br>　　<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">if(lock.tryLock()) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">         //处理任务</span><br><span class="line">     &#125;catch(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;finally&#123;</span><br><span class="line">         lock.unlock();   //释放锁</span><br><span class="line">     &#125; </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    //如果不能获取锁，则直接做其他事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>　　由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><p>　　因此lockInterruptibly()一般的使用形式如下：<br>　　<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method() throws InterruptedException &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;  </span><br><span class="line">     //.....</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p>　　因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p>　　而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。　　</p><h4 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h4><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p><p>　　例子1，lock()的正确使用方法<br>　　<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>各位朋友先想一下这段代码的输出结果是什么？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-1得到了锁</span><br><span class="line">Thread-0释放了锁</span><br><span class="line">Thread-1释放了锁</span><br></pre></td></tr></table></figure><p>也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。</p><p>知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就是正确地使用Lock的方法了。</p><p>例子2，tryLock()的使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"获取锁失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-1获取锁失败</span><br><span class="line">Thread-0释放了锁</span><br></pre></td></tr></table></figure><p>例子3，lockInterruptibly()响应中断的使用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly();   <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，发现thread2能够被正确中断。</p><h4 id="3-ReadWriteLock"><a href="#3-ReadWriteLock" class="headerlink" title="3.ReadWriteLock"></a>3.ReadWriteLock</h4><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><h4 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4.ReentrantReadWriteLock"></a>4.ReentrantReadWriteLock</h4><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><p>下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</p><p>假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br></pre></td></tr></table></figure><p>而改成用读写锁的话：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打印的结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br></pre></td></tr></table></figure><p>说明thread1和thread2在同时进行读操作。</p><p>　　这样就大大提升了读操作的效率。</p><p>　　不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p><p>　　如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><p>　　关于ReentrantReadWriteLock类中的其他方法感兴趣的朋友可以自行查阅API文档。</p><p>　　5.Lock和synchronized的选择</p><p>　　总结来说，Lock和synchronized有以下几点不同：</p><p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>　　5）Lock可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。　　</p><h2 id="三-锁的相关概念介绍"><a href="#三-锁的相关概念介绍" class="headerlink" title="三.锁的相关概念介绍"></a>三.锁的相关概念介绍</h2><p>在前面介绍了Lock的基本使用，这一节来介绍一下与锁相关的几个概念。</p><h4 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1.可重入锁"></a>1.可重入锁</h4><p>　　如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>　　看下面这段代码就明白了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p><h4 id="2-可中断锁"><a href="#2-可中断锁" class="headerlink" title="2.可中断锁"></a>2.可中断锁</h4><p>可中断锁：顾名思义，就是可以相应中断的锁。</p><p>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><h4 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="3.公平锁"></a>3.公平锁</h4><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p>看一下这2个类的源代码就清楚了：</p><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201808011448-java-lock.jpg?imageView2/2/w/1536"><p>201808011448-java-lock</p><p>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。</p><p>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>如果参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p><p>　　</p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><p>　　isFair()        //判断锁是否是公平锁</p><p>　　isLocked()    //判断锁是否被任何线程获取了</p><p>　　isHeldByCurrentThread()   //判断锁是否被当前线程获取了</p><p>　　hasQueuedThreads()   //判断是否有线程在等待该锁</p><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h4 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h4><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p><p>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p><p>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p><p>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p><p>上面已经演示过了读写锁的使用方法，在此不再赘述。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx:安装和常用命令</title>
      <link href="/posts/8747ea0e/"/>
      <url>/posts/8747ea0e/</url>
      <content type="html"><![CDATA[<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>从官网下载<code>nginx</code>压缩包，官网地址：<code>https://nginx.org/en/download.html</code>。最好选择稳定版本。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>假设下载的安装包位于<code>/root/</code>用户根目录下。</p><p>1、解压文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.15.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>2、自定义nginx安装位置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建文件夹</span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir nginx-1.15.2</span><br><span class="line"></span><br><span class="line">#回到解压文件夹</span><br><span class="line">cd /root/nginx-1.15.2</span><br><span class="line">指定安装路径</span><br><span class="line">./configure --prefix=/usr/local/nginx-1.15.2</span><br><span class="line">编译安装</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>先进入到nginx的安装路径，可以看到目录结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwx------ 2 root root    6 7月  30 19:05 client_body_temp</span><br><span class="line">drwxr-xr-x 2 root root 4096 7月  30 19:16 conf</span><br><span class="line">drwx------ 2 root root    6 7月  30 19:05 fastcgi_temp</span><br><span class="line">drwxr-xr-x 5 root root  141 7月  30 19:15 html</span><br><span class="line">drwxr-xr-x 2 root root   58 7月  30 19:12 logs</span><br><span class="line">drwx------ 2 root root    6 7月  30 19:05 proxy_temp</span><br><span class="line">drwxr-xr-x 2 root root   19 7月  30 19:04 sbin</span><br><span class="line">drwx------ 2 root root    6 7月  30 19:05 scgi_temp</span><br><span class="line">drwx------ 2 root root    6 7月  30 19:05 uwsgi_temp</span><br></pre></td></tr></table></figure><p>其中，conf是配置文件，html是静态文件目录，logs是错误日志目录，sbin是执行文件目录</p><p>1、启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx</span><br></pre></td></tr></table></figure><p>2、停止</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p>3、重载配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nignx -s reload</span><br></pre></td></tr></table></figure><p>4、指定配置文件启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -c /conf/nginx.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Appium:分布式测试环境搭建</title>
      <link href="/posts/4e971816/"/>
      <url>/posts/4e971816/</url>
      <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>同时向大量的跨平台机器推送脚本，执行测试。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-Selenium-Standalone-Server"><a href="#1-Selenium-Standalone-Server" class="headerlink" title="1.Selenium Standalone Server"></a>1.Selenium Standalone Server</h3><p>1、下载<code>jar</code>包，地址为：<code>https://www.seleniumhq.org/download/</code></p><p>2、启动服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar selenium-server-standalone-&lt;version&gt;.jar -role hub</span><br></pre></td></tr></table></figure><p>服务启动后，访问：<code>localhost：4444</code>验证。</p><p>3、编辑节点配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;capabilities&quot;:</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;browserName&quot;: &quot;&lt;e.g._iPhone5_or_iPad4&gt;&quot;,</span><br><span class="line">          &quot;version&quot;:&quot;&lt;version_of_iOS_e.g._7.1&gt;&quot;,</span><br><span class="line">          &quot;maxInstances&quot;: 1,</span><br><span class="line">          &quot;platform&quot;:&quot;&lt;platform_e.g._MAC_or_ANDROID&gt;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">  &quot;configuration&quot;:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;cleanUpCycle&quot;:2000,</span><br><span class="line">    &quot;timeout&quot;:30000,</span><br><span class="line">    &quot;proxy&quot;: &quot;org.openqa.grid.selenium.proxy.DefaultRemoteProxy&quot;,</span><br><span class="line">    &quot;url&quot;:&quot;http://&lt;host_name_appium_server_or_ip-address_appium_server&gt;:&lt;appium_port&gt;/wd/hub&quot;,</span><br><span class="line">    &quot;host&quot;: &lt;host_name_appium_server_or_ip-address_appium_server&gt;,</span><br><span class="line">    &quot;port&quot;: &lt;appium_port&gt;,</span><br><span class="line">    &quot;maxSession&quot;: 1,</span><br><span class="line">    &quot;register&quot;: true,</span><br><span class="line">    &quot;registerCycle&quot;: 5000,</span><br><span class="line">    &quot;hubPort&quot;: &lt;grid_port&gt;,</span><br><span class="line">    &quot;hubHost&quot;: &quot;&lt;Grid_host_name_or_grid_ip-address&gt;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果没有给出 url、host 和 port，配置会自动指向 localhost:whatever-port-Appium-started-on。</p><p>如果你的 Appium Server 和 Selenium Grid 没有运行在同一台机器上，为确保 Selenium Grid 连接正常，请在你的 host &amp; url 上使用外部域名或 IP 地址，而不是 localhost 和 127.0.0.1</p><p>4、指定配置文件启动Appuium节点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appium -p 4724 -bp 4714 --nodeconfig &quot;json文件路径&quot;</span><br></pre></td></tr></table></figure></p><p>其中，<code>-p</code>与配置文件中的<code>port</code>一致，即指定<code>appium</code>启动的端口号，<code>-bp</code>是手机客户端<code>bootStrap</code>监听的端口号</p><p>启动后，控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Appium] Appium support for versions of node &lt; 8 has been deprecated and will be removed in a future version. Please upgrade!</span><br><span class="line">[Appium] Welcome to Appium v1.8.1</span><br><span class="line">[Appium] Non-default server args:</span><br><span class="line">[Appium]   port: 4724</span><br><span class="line">[Appium]   bootstrapPort: 4714</span><br><span class="line">[Appium]   nodeconfig: SM-G9550</span><br><span class="line">[debug] [Appium] Starting auto register thread for grid. Will try to register every 5000 ms.</span><br><span class="line">[Appium] Appium REST http interface listener started on 0.0.0.0:4724</span><br><span class="line">[debug] [Appium] Appium successfully registered with the grid on http://localhost:4444</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Selenium Grid会发生阻塞，如果上一个测试任务因为异常无法继续执行会发生阻塞，后面的测试任务无法继续执行</p><h2 id="Selenium-Grid-架构"><a href="#Selenium-Grid-架构" class="headerlink" title="Selenium Grid 架构"></a>Selenium Grid 架构</h2><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/selenium-grid架构图.png?imageView2/2/w/1536"><p>什么时 Hub呢？</p><p>它是你加载所有测试的机器。</p><p>一个Grid里只有一个Hub。</p><p>hub是测试运行的地方，但是你看到的测试是在node上的浏览器上执行的。</p><p>什么是Nodes？</p><p>这台机器将执行您在hub上加载的测试</p><p>他可以是一个或者多个nodes在一个grid里，Grid中有不同浏览器和操作系统。</p><h4 id="做成多线程方式"><a href="#做成多线程方式" class="headerlink" title="做成多线程方式"></a>做成多线程方式</h4><p>Selenium Grid只是提供多系统、多浏览器的执行环境，而不是说任务一个test case丢给它就能并行运行。并行的运行我这里就交给testng了</p>]]></content>
      
      <categories>
          
          <category> Appium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Appium </tag>
            
            <tag> Grid </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quartz：Listener注入Spring对象</title>
      <link href="/posts/1b401ae4/"/>
      <url>/posts/1b401ae4/</url>
      <content type="html"><![CDATA[<p>我们知道，由于<code>listener</code>启动会先于<code>spring</code>容器。况且<code>quratz</code> 中的<code>bean</code>是独立于<code>spring</code>外运行的，也就是说<code>spring</code>把创建<code>bean</code>的生命周期权限托管给了<code>quratz</code>所以要想在<code>job</code> 或者<code>job</code>的<code>listener</code>中注入<code>spring</code>的<code>bean</code>肯定是不行的 但是我们可以使用别的方法。下面我写一个自己认为最简单的方法：</p><p>先创建一个<code>spring</code>的<code>SpringUtil</code>的工具类，该工具类主要是利用实现了<code>ApplicationContextAware</code>接口，利用<code>set</code>方法先实例化一个<code>ApplicationContext</code>，然后就可以获取对应的bean源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SpringUtil.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            SpringUtil.applicationContext = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取applicationContext</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过name获取 Bean.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过class获取Bean.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过name,以及Clazz返回指定的Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySchedulerListener</span> <span class="keyword">implements</span> <span class="title">SchedulerListener</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobScheduled</span><span class="params">(Trigger trigger)</span> </span>&#123;</span><br><span class="line">        MyBatisMapper myBatisMapper = (MyBatisMapper)SpringUtil.getBean(MyBatisMapper.class);</span><br><span class="line">        myBatisMapper.updateByPrimaryKey(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"任务被部署时被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库：MySQL常用语句</title>
      <link href="/posts/a81bce10/"/>
      <url>/posts/a81bce10/</url>
      <content type="html"><![CDATA[<h2 id="查询字段为null或者不为null"><a href="#查询字段为null或者不为null" class="headerlink" title="查询字段为null或者不为null"></a>查询字段为null或者不为null</h2><p>在<code>mysql</code>中，查询某字段为空时，切记不可用<code>= null</code>，而是 <code>is null</code>，不为空则是<code>is not null</code>，示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where column is null;</span><br><span class="line">select * from table where column is not null;</span><br></pre></td></tr></table></figure><h2 id="group-by-异常"><a href="#group-by-异常" class="headerlink" title="group by 异常"></a>group by 异常</h2><p>MySQL5.7 后将<code>sql_mode</code>的<code>ONLY_FULL_GROUP_BY</code>模式默认设置为打开状态，这样一来，很多之前的sql语句可能会出现错误，错误信息如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error Code: 1055. Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;×××&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>1、查看sql_mode</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@sql_mode</span><br></pre></td></tr></table></figure><p>查询出来的值为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><p>2、去掉ONLY_FULL_GROUP_BY，重新设置值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER</span><br><span class="line">,NO_ENGINE_SUBSTITUTION&apos;;</span><br></pre></td></tr></table></figure><p>3、上面是改变了全局sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;</span><br></pre></td></tr></table></figure><p>4、以上的改表方式只能临时生效，在MySQL重启之后就失效了，想要一劳永逸的办法，就是修改配置文件。RPM的安装方式，配置文件位于<code>/etc/my.cnf</code>，增加如下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><h2 id="忽略表名大小写"><a href="#忽略表名大小写" class="headerlink" title="忽略表名大小写"></a>忽略表名大小写</h2><p>在配置文件<code>my.cnf</code>在增加如下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#默认是0，区分大小写；1忽略大小写</span><br><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure><p>如果原有的数据库表中有大写的表名，在配置生效后，会出现该表查找不到的异常。在配置之前，将含有大写的表导出，在配置生效之后，重新导入，可以消除异常。</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务：Zuul转发后文件名乱码</title>
      <link href="/posts/e7f3dec2/"/>
      <url>/posts/e7f3dec2/</url>
      <content type="html"><![CDATA[<p>最近在使用 SpringCloud 搭建微服务的过程中，发现上传文件经过 Zuul 网关转发的时候，因为上传文件名中文乱码，导致文件的写操作失败。但是不经过 Zuul 转发的时候，文件上传正常，因此猜测是 Zuul 对上传的请求的编码进行了处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原文件名：file中文.txt</span><br><span class="line">上传后：file__.txt</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决方法如下："><a href="#解决方法如下：" class="headerlink" title="解决方法如下："></a>解决方法如下：</h2><h3 id="一、增加请求前缀"><a href="#一、增加请求前缀" class="headerlink" title="一、增加请求前缀"></a>一、增加请求前缀</h3><p>在上传文件的请求路径之前添加字符串<code>zuul</code>声明。网关将所有带<code>/zuul</code>请求的请求都走<code>zuulServlet</code>，不带<code>zuul</code>的请求都走<code>spring mvc</code>的<code>dispatchServlet</code>，避免多余的编码处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原请求路径：http://localhost:8080/uploadFile</span><br><span class="line">修改后：http://localhost:8080/zuul/uploadFile</span><br></pre></td></tr></table></figure><h3 id="二、增加-application-property-属性"><a href="#二、增加-application-property-属性" class="headerlink" title="二、增加 application.property 属性"></a>二、增加 application.property 属性</h3><p>在方案一的基础上，主要修改前端代码，也可以在<code>application.property</code>声明属性来处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zuul.servlet-path=/</span><br></pre></td></tr></table></figure><p>但是，如果前端文件部署在网关上，会由于所有的请求都跳过<code>spring mvc</code>处理，而无法正常渲染前端页面。因此，请根据实际需求选择解决方案。</p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zuul </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本管理：Git代码冲突常见解决方法</title>
      <link href="/posts/fbabd5d1/"/>
      <url>/posts/fbabd5d1/</url>
      <content type="html"><![CDATA[<p>如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候，在发布这个配置文件的时候,会发生代码冲突:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">        protected/config/main.php</span><br><span class="line">Please, commit your changes or stash them before you can merge.</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>然后可以使用<code>git diff -w +文件名</code>来确认代码自动合并的情况.</p><p>反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>其中<code>git reset</code>是针对版本,如果想针对文件回退本地修改,使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout HEAD file/to/restore</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JAVA：流</title>
      <link href="/posts/9c74640c/"/>
      <url>/posts/9c74640c/</url>
      <content type="html"><![CDATA[<p>*<em>Java核心技术卷二-读书笔记</em></p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p><strong>输入流：</strong>可以从其中读入字节序列的对象；<br><strong>输出流：</strong>可以向其中写入字节序列的对象；</p><p>抽象类<code>InputStream</code>和<code>OutputStream</code>构成输入/输出(I/O)类层次结构基础。</p><p><code>Unicode</code>中每个字符都使用多个字节表示，以上面向字节的流不便处理，因此，从抽象类<code>Reader</code>和<code>Writer</code>中继承出专用于处理<code>Unicode</code>字符的类层次结构，且读写操作都基于<strong>两字节</strong>的Unicode码元。<br><a id="more"></a></p><h3 id="读写字节"><a href="#读写字节" class="headerlink" title="读写字节"></a>读写字节</h3><p><code>adstract int read()</code></p><p><code>InputStream</code>类的抽象方法，作用是：读入一个字节，并返回读入的字节，或者在遇到输入源结尾时返回<code>-1</code>。具体的输入流类必须覆盖此方法以提供适用的功能。</p><p><code>abstract void write(int b)</code></p><p><code>OutputStream</code>的抽象方法，用于向某个输出位置写出一个字节。</p><p><code>read</code>和<code>write</code>方法在执行时都将阻塞，直至字节确实被读入或写出。</p><p><code>available</code>方法用于检查当前可读入的字节数量。以下的代码写法就不可能被阻塞，因为<strong>字节数组的长度被确定</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesAvailable = in.available();</span><br><span class="line"><span class="keyword">if</span> (bytesAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[bytesAvailable];</span><br><span class="line">in.read(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成对流的读写后，应调用<code>close</code>方法关闭它，释放系统资源。关闭<strong>输出流</strong>的同时，还会冲刷用于该输出流的缓冲区（buffer）：字节输出时，先被置于临时缓冲区中，再以更大的包（block）的形式写出，当关闭输出流时，会将缓冲区内容输出。如果不关闭，那么写出字节的最后一个包可能永远也无法输出。当然，也可以用<code>flush</code>方法强制输出。</p><h4 id="组合流过滤器"><a href="#组合流过滤器" class="headerlink" title="组合流过滤器"></a>组合流过滤器</h4><p>FileInputStream和FileOutputStream可以通过文件路径读取磁盘文件上的输入/输出流，并且只能从<code>fin</code>对象中读入字节和字节数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.dat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)fin.read();</span><br></pre></td></tr></table></figure><p>提示：java.io的相对路径以用户工作目录开始，调用<code>System.getProperty(&quot;user.dir&quot;)</code>来获取。</p><p>DataInputStream只能读入数值类型，而不能从文件获取数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataInputStream din = ...;</span><br><span class="line">double s = din.readDouble();</span><br></pre></td></tr></table></figure><p>如果希望从文件或者其他外部位置获取字节，再将其组装到更有用的数据类型中（如数字类型），则必须对二者进行组合。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileInputStream fin = new FileInputStream(&quot;employee.dat&quot;);</span><br><span class="line">DataInputStream din = new DataInputStream(fin);</span><br><span class="line">double s = din.readDouble();</span><br></pre></td></tr></table></figure><p>再例如，默认情况下流的读取时不被缓冲区缓存的，每调用一次<code>read</code>会请求操作系统再分发一个字节。要想使用<strong>缓冲机制</strong>，并从文件获取数据，就需要如下的构造器序列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataInputStream din = new DataInputStream(</span><br><span class="line">new BufferInputStream(</span><br><span class="line">new FileInputStream(&quot;employee.dat&quot;)));</span><br></pre></td></tr></table></figure><h3 id="文本输入与输出"><a href="#文本输入与输出" class="headerlink" title="文本输入与输出"></a>文本输入与输出</h3><p>保存数据时，可以选择二进制格式或者文本格式。尽管二进制格式的I/O高效且高速，但是难以阅读。</p><p>在存储文本字符串时，需要考虑字符编码（character encoding）方式，如UTF-16、ISO 8859-1等。</p><p><code>OutputStreamWriter</code>类使用选定的字符编码方式，把Unicode<strong>字符流</strong>转换为<strong>字节流</strong>。而<code>InputStreamReader</code>类将字节输入流转为可以产生Unicode码元的读入器。</p><p>例如，从控制台读入键盘敲击信息，并转为Unicode：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader in = <span class="keyword">new</span> InputStreamReader(System.in);</span><br></pre></td></tr></table></figure><p>这个<code>InputStreamReader</code>使用系统默认字符编码方式，如需指定不同的编码方式，则可用以下方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader in = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(<span class="string">"kremlin.dat"</span>), <span class="string">"ISO8859_5"</span>);</span><br></pre></td></tr></table></figure><h4 id="如何写出文本输出"><a href="#如何写出文本输出" class="headerlink" title="如何写出文本输出"></a>如何写出文本输出</h4><p><code>PrintWriter</code>类拥有以文本格式打印字符串和数字的方法，再使用与<code>System.out</code>相同的<code>print</code>、<code>println</code>和<code>printf</code>方法打印数字、字符、布尔值、字符串和对象到文件中。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"employee.txt"</span>);</span><br><span class="line"></span><br><span class="line">String name = <span class="string">"Harry Hacker"</span>;</span><br><span class="line"><span class="keyword">double</span> salary = <span class="number">75000</span>;</span><br><span class="line">out.print(name);</span><br><span class="line">out.print(<span class="string">' '</span>);</span><br><span class="line">out.println(salary);</span><br></pre></td></tr></table></figure><p>输出以下内容到 employee.txt 中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Harry Hacker 75000.0</span><br></pre></td></tr></table></figure><h4 id="如何读入文本输入"><a href="#如何读入文本输入" class="headerlink" title="如何读入文本输入"></a>如何读入文本输入</h4><p>在 Java SE 5.0 之前，通过<code>BufferedReader</code>类的<code>readLine</code>方法读入一行文本。<code>readLine</code>在没有输入时返回 <strong>null</strong>。以下示例集成缓冲功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>), <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line - in.readLine()) != <span class="keyword">null</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> something with line</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，<code>BufferedReader</code>不能读入数字，建议使用<code>Scanner</code>来处理。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> InputStream </tag>
            
            <tag> OutputStream </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA：[转]深入理解abstract class和interface</title>
      <link href="/posts/a494d8f4/"/>
      <url>/posts/a494d8f4/</url>
      <content type="html"><![CDATA[<h2 id="理解抽象类"><a href="#理解抽象类" class="headerlink" title="理解抽象类"></a>理解抽象类</h2><p>abstract class和interface在Java语言中都是用来进行抽象类（本文中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法，请读者注意区分）定义的，那么什么是抽象类，使用抽象类能为我们带来什么好处呢？</p><p>在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。<br><a id="more"></a></p><p>在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；同时，通过从这个抽象体派生，也可扩展此模块的行为功能。熟悉OCP的读者一定知道，为了能够实现面向对象设计的一个最核心的原则OCP( Open-Closed Principle)，抽象类是其中的关键所在。</p><h2 id="从语法定义层面看abstract-class和interface"><a href="#从语法定义层面看abstract-class和interface" class="headerlink" title="从语法定义层面看abstract class和interface"></a>从语法定义层面看abstract class和interface</h2><p>在语法层面，Java语言对于abstract class和interface给出了不同的定义方式，下面以定义一个名为Demo的抽象类为例来说明这种不同。</p><p>使用abstract class的方式定义Demo抽象类的方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Demo ｛</span><br><span class="line">    abstract void method1();</span><br><span class="line">    abstract void method2();</span><br><span class="line">    …</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>使用interface的方式定义Demo抽象类的方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Demo &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    void method2();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract class。</p><p>对于abstract class和interface在语法定义层面更多的细节问题，不是本文的重点，不再赘述，读者可以参阅参考文献〔1〕获得更多的相关内容。</p><h2 id="从编程层面看abstract-class和interface"><a href="#从编程层面看abstract-class和interface" class="headerlink" title="从编程层面看abstract class和interface"></a>从编程层面看abstract class和interface</h2><p>从编程的角度来看，abstract class和interface都可以用来实现”design by contract”的思想。但是在具体的使用上面还是有一些区别的。</p><p>首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。</p><p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会 增加一些复杂性，有时会造成很大的麻烦。</p><p>在抽象类中不能定义默认行为还存在另一个比较严重的问题，那就是可能会造成维护上的麻烦。因为如果后来想修改类的界面（一般通过abstract class或者interface来表示）以适应新的情况（比如，添加新的方法或者给已用的方法中添加新的参数）时，就会非常的麻烦，可能要花费很多的时间（对于派生类很多的情况，尤为如此）。但是如果界面是通过abstract class来实现的，那么可能就只需要修改定义在abstract class中的默认行为就可以了。</p><p>同样，如果不能在抽象类中定义默认行为，就会导致同样的方法实现出现在该抽象类的每一个派生类中，违反了”one rule，one place”原则，造成代码重复，同样不利于以后的维护。因此，在abstract class和interface间进行选择时要非常的小心。</p><h2 id="从设计理念层面看abstract-class和interface"><a href="#从设计理念层面看abstract-class和interface" class="headerlink" title="从设计理念层面看abstract class和interface"></a>从设计理念层面看abstract class和interface</h2><p>上面主要从语法定义和编程的角度论述了abstract class和interface的区别，这些层面的区别是比较低层次的、非本质的。本小节将从另一个层面：abstract class和interface所反映出的设计理念，来分析一下二者的区别。作者认为，从这个层面进行分析才能理解二者概念的本质所在。</p><p>前面已经提到过，abstarct class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is a”关系，即父类和派生类在概念本质上应该是相同的（参考文献〔3〕中有关于”is a”关系的大篇幅深入的论述，有兴趣的读者可以参考）。对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。为了使论述便于理解，下面将通过一个简单的实例进行说明。</p><p>考虑这样一个例子，假设在我们的问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close，此时我们可以通过abstract class或者interface来定义一个表示该抽象概念的类型，定义方式分别如下所示：</p><p>使用abstract class方式定义Door：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Door &#123;</span><br><span class="line">        abstract void open();</span><br><span class="line">        abstract void close()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用interface方式定义Door：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Door &#123;</span><br><span class="line">        void open();</span><br><span class="line">    void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他具体的Door类型可以extends使用abstract class方式定义的Door或者implements使用interface方式定义的Door。看起来好像使用abstract class和interface没有大的区别。</p><p>如果现在要求Door还要具有报警的功能。我们该如何设计针对该例子的类结构呢（在本例中，主要是为了展示abstract class和interface反映在设计理念上的区别，其他方面无关的问题都做了简化或者忽略）？下面将罗列出可能的解决方案，并从设计理念层面对这些不同的方案进行分析。</p><h4 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h4><p>简单的在Door的定义中增加一个alarm方法，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Door &#123;</span><br><span class="line">        abstract void open();</span><br><span class="line">        abstract void close()；</span><br><span class="line">        abstract void alarm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Door &#123;</span><br><span class="line">        void open();</span><br><span class="line">    void close();</span><br><span class="line">    void alarm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么具有报警功能的AlarmDoor的定义方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AlarmDoor extends Door &#123;</span><br><span class="line">        void open() &#123; … &#125;</span><br><span class="line">            void close() &#123; … &#125;</span><br><span class="line">        void alarm() &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AlarmDoor implements Door ｛</span><br><span class="line">    void open() &#123; … &#125;</span><br><span class="line">            void close() &#123; … &#125;</span><br><span class="line">        void alarm() &#123; … &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>这种方法违反了面向对象设计中的一个核心原则ISP（Interface Segregation Priciple），在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变（比如：修改alarm方法的参数）而改变，反之依然。</p><h4 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h4><p>既然open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中。定义方式有：这两个概念都使用abstract class方式定义；两个概念都使用interface方式定义；一个概念使用abstract class方式定义，另一个概念使用interface方式定义。</p><p>显然，由于Java语言不支持多重继承，所以两个概念都使用abstract class方式定义是不可行的。后面两种方式都是可行的，但是对于它们的选择却反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理。我们一一来分析、说明。</p><p>如果两个概念都使用interface方式来定义，那么就反映出两个问题：1、我们可能没有理解清楚问题领域，AlarmDoor在概念本质上到底是Door还是报警器？2、如果我们对于问题领域的理解没有问题，比如：我们通过对于问题领域的分析发现AlarmDoor在概念本质上和Door是一致的，那么我们在实现时就没有能够正确的揭示我们的设计意图，因为在这两个概念的定义上（均使用interface方式定义）反映不出上述含义。</p><p>如果我们对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它有具有报警的功能。我们该如何来设计、实现来明确的反映出我们的意思呢？前面已经说过，abstract class在Java语言中表示一种继承关系，而继承关系在本质上是”is a”关系。所以对于Door这个概念，我们应该使用abstarct class方式来定义。另外，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义。如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Door &#123;</span><br><span class="line">        abstract void open();</span><br><span class="line">        abstract void close()；</span><br><span class="line">    &#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    void alarm();</span><br><span class="line">&#125;</span><br><span class="line">class AlarmDoor extends Door implements Alarm &#123;</span><br><span class="line">    void open() &#123; … &#125;</span><br><span class="line">    void close() &#123; … &#125;</span><br><span class="line">    void alarm() &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实abstract class表示的是”is a”关系，interface表示的是”like a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>abstract class和interface是Java语言中的两种定义抽象类的方式，它们之间有很大的相似性。但是对于它们的选择却又往往反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理，因为它们表现了概念间的不同的关系（虽然都能够实现需求的功能）。这其实也是语言的一种的惯用法，希望读者朋友能够细细体会。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Quartz:常见异常</title>
      <link href="/posts/6ed02c97/"/>
      <url>/posts/6ed02c97/</url>
      <content type="html"><![CDATA[<h2 id="持久化模式常见异常"><a href="#持久化模式常见异常" class="headerlink" title="持久化模式常见异常"></a>持久化模式常见异常</h2><h3 id="无数据源"><a href="#无数据源" class="headerlink" title="无数据源"></a>无数据源</h3><p>完成持久化的配置之后，仍然无法连接到数据库，报错的内容是：<code>C3P0的connectionProvider</code>初始化失败。查了很多资料，再结合错误信息，花了半天时间，才发现：原来<code>quartz</code>默认使用了<code>C3P0</code>的数据源，然而<code>quartz</code>的依赖包中并没有<code>C3P0</code>的依赖，因此无法初始化连接器。解决方法：只要在<code>maven</code>管理的<code>POM.xml</code>中把<code>C3P0</code>的依赖加上就可以了。</p><h3 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h3><p>MySQL服务器默认的“wait_timeout”是28800秒即8小时，意味着如果一个连接的空闲时间超过8个小时，MySQL将自动断开该连接，而连接池却认为该连接还是有效的(因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致异常发生。</p><p>在本文，由于我们的C3P0连接池没有配置连接有效性检查，导致quartz使用的连接线程可能超时无效。<br><a id="more"></a><br>错误如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JobStoreTX - MisfireHandler: Error handling misfires: Database error recovering from misfires.</span><br><span class="line"></span><br><span class="line">Another error has occurred </span><br><span class="line">[ com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: No operations allowed after connection closed. ] </span><br><span class="line">which will not be reported to listeners!</span><br></pre></td></tr></table></figure></p><p>解决这个问题的办法有三种，但是推荐第二种——减少连接池内连接的生命周期。</p><h4 id="1-增加-MySQL-的-wait-timeout-属性的值"><a href="#1-增加-MySQL-的-wait-timeout-属性的值" class="headerlink" title="1. 增加 MySQL 的 wait_timeout 属性的值"></a>1. 增加 MySQL 的 wait_timeout 属性的值</h4><p>修改mysql安装目录下的配置文件 my.ini文件（如果没有此文件， 复制“my-default.ini”文件，生成“复件 my-default.ini”文件。 将“复件 my-default.ini”文件重命名成“my.ini” ），在文件中设置： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait_timeout=31536000  </span><br><span class="line">interactive_timeout=31536000</span><br></pre></td></tr></table></figure><h4 id="2-减少连接池内连接的生存周期"><a href="#2-减少连接池内连接的生存周期" class="headerlink" title="2. 减少连接池内连接的生存周期"></a>2. 减少连接池内连接的生存周期</h4><p>减少连接池内连接的生存周期， 使之小于 上一项中所设置的 wait_timeout 的值。<br>此处修改Quartz的c3p0配置信息，内容如下：</p><p><strong>org.quartz.dataSource.NAME.validationQuery</strong><br>增加用于验证连接有效性的数据库查询语句，如<code>select count(*) from QRTZ_CALENDARS</code></p><p><strong>org.quartz.dataSource.NAME.validateOnCheckout</strong><br>只有配置了<code>validationQuery</code>之后，才能设置为<code>true</code></p><p><strong>org.quartz.dataSource.NAME.idleConnectionValidationSeconds</strong><br>只有配置了<code>validationQuery</code>之后，才能配置有效性查询的时间间隔，默认50s</p><p><strong>org.quartz.dataSource.NAME.discardIdleConnectionsSeconds</strong><br>废弃空闲连接的时间，默认是0s</p><p>参考：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.x/configuration/ConfigDataSources.html" target="_blank" rel="noopener">Quartz官方文档</a></p><h4 id="3-定期使用连接池内的连接"><a href="#3-定期使用连接池内的连接" class="headerlink" title="3. 定期使用连接池内的连接"></a>3. 定期使用连接池内的连接</h4><p>定期使用连接池内的连接，使得它们不会因为闲置超时而被 MySQL 断开。 </p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven:管理本地jar包</title>
      <link href="/posts/46b8b7d2/"/>
      <url>/posts/46b8b7d2/</url>
      <content type="html"><![CDATA[<p>Maven依赖管理，可以很方便的帮助我们添加所需的jar包。但是，大部分情况，这些jar包都是Maven项目。如果我们需要引入自定义的jar包，又该如何处理呢？</p><p>起初，我在项目中新建<code>lib</code>文件夹，并把自定义的jar包放进去，然后，在<code>pom.xml</code>中进行如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;dd-plist&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dd-plist&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">&lt;systemPath&gt;$&#123;project.basedir&#125;/lib/dd-plist.jar&lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>结果，本地使用IDE运行调试时没有问题，但是打成jar包上传到服务器却找不到该jar包中的类文件。</p><p>为了解决这个问题，我找到了如下的方案。</p><a id="more"></a><h2 id="1-在项目的目录下创建lib文件夹"><a href="#1-在项目的目录下创建lib文件夹" class="headerlink" title="1 在项目的目录下创建lib文件夹"></a>1 在项目的目录下创建lib文件夹</h2><h2 id="2-使用Maven安装自定义jar包"><a href="#2-使用Maven安装自定义jar包" class="headerlink" title="2 使用Maven安装自定义jar包"></a>2 使用Maven安装自定义jar包</h2><p>在命令行执行以下命令，可以安装自定义jar包到我们指定的lib文件夹。注意配置好自定义jar包的路径。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install:install-file </span><br><span class="line">-Dfile=path_to_mylib.jar -DgroupId=com.mylib </span><br><span class="line">-DartifactId=jar_name -Dversion=1.0 -Dpackaging=jar </span><br><span class="line">-DlocalRepositoryPath=path_to_my_project/lib</span><br></pre></td></tr></table></figure><p>执行成功后，终端显示内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]                                                                         </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---</span><br><span class="line">[INFO] Installing path_to_mylib.jar to path_to_my_project/lib/com/mylib/jar_name/1.0/dd-plist-1.0.jar</span><br><span class="line">[INFO] Installing /var/folders/r5/86whqmls4y36p5qgnhwstr6w0000gn/T/mvninstall2596441059296695813.pom to path_to_my_project/lib/com/mylib/jar_name/1.0/dd-plist-1.0.pom</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 0.413 s</span><br><span class="line">[INFO] Finished at: 2018-06-01T10:13:20+08:00</span><br><span class="line">[INFO] Final Memory: 9M/309M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="3-配置POM文件"><a href="#3-配置POM文件" class="headerlink" title="3 配置POM文件"></a>3 配置POM文件</h2><p>按如下文件配置POM.xml，配置完成之后，重新执行<code>Maven Reimport</code>，即可生效。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">     &lt;repository&gt;</span><br><span class="line">         &lt;!-- DO NOT set id to &quot;local&quot; because it is reserved by Maven --&gt;</span><br><span class="line">         &lt;id&gt;lib&lt;/id&gt;</span><br><span class="line">         &lt;url&gt;file://$&#123;project.basedir&#125;/lib&lt;/url&gt;</span><br><span class="line">     &lt;/repository&gt;</span><br><span class="line">  &lt;/repositories&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.mylib&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mylib&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过以上方式配置的自定义jar包，在工程打包部署后仍然可以生效。具体的原理，可以留言给我。我很乐意多学习一些Maven的知识。</p>]]></content>
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>足迹：富春桃源</title>
      <link href="/posts/ec6986a1/"/>
      <url>/posts/ec6986a1/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201805190945.jpeg?imageView2/2/w/1536"><a id="more"></a><p>2018年5月19日<br>和S一起来到富春桃园，参加她们公司的TB。当天淫雨霏霏，初晴乍雨，空气清新潮湿。</p><p>大巴先到了图中的码头，放眼望去，确实有一种古时吴越之地那种“沉舟侧畔千帆过，病树前头万木春“的意境。一日的行程，终止于此。期间历经登山、穿越溶洞、轨道滑行、农家乐、竹筏漂流。登岸时，仰望天际，有种”激流勇进，放浪天涯“的冲动。</p>]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo：常用命令</title>
      <link href="/posts/c8dcc28b/"/>
      <url>/posts/c8dcc28b/</url>
      <content type="html"><![CDATA[<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>草稿相当于很多博客都有的“私密文章”功能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;new draft&quot;</span><br></pre></td></tr></table></figure><p>会在<code>source/_drafts</code>目录下生成一个<code>new-draft.md</code>文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到<code>_drafts</code>目录之中。</p><p>如果你希望强行预览草稿，更改配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure><p>或者，如下方式启动server：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server --drafts</span><br></pre></td></tr></table></figure><p>下面这条命令可以把草稿变成文章，或者页面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 草稿 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务[Exception]：Zuul无法访问负载均衡服务</title>
      <link href="/posts/8e887edc/"/>
      <url>/posts/8e887edc/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用zuul的负载均衡功能时，无法访问负载均衡服务</p><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><ol><li>使用Eureka作为服务注册</li><li>zuul配置路由匹配规则为服务化的路由规则</li></ol><a id="more"></a><h4 id="异常如下"><a href="#异常如下" class="headerlink" title="异常如下"></a>异常如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15:50:18.013 Gateway [http-nio-9090-exec-6] WARN  o.s.c.n.z.f.post.SendErrorFilter - Error during filtering</span><br><span class="line">com.netflix.zuul.exception.ZuulException: Forwarding error</span><br><span class="line">at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.handleException(RibbonRoutingFilter.java:189)</span><br><span class="line">at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.forward(RibbonRoutingFilter.java:164)</span><br><span class="line">at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.run(RibbonRoutingFilter.java:111)</span><br><span class="line">at com.netflix.zuul.ZuulFilter.runFilter(ZuulFilter.java:112)</span><br><span class="line">at com.netflix.zuul.FilterProcessor.processZuulFilter(FilterProcessor.java:193)</span><br><span class="line">at com.netflix.zuul.FilterProcessor.runFilters(FilterProcessor.java:157)</span><br><span class="line">at com.netflix.zuul.FilterProcessor.route(FilterProcessor.java:118)</span><br><span class="line">at com.netflix.zuul.ZuulRunner.route(ZuulRunner.java:96)</span><br><span class="line">at com.netflix.zuul.http.ZuulServlet.route(ZuulServlet.java:116)</span><br><span class="line">at com.netflix.zuul.http.ZuulServlet.service(ZuulServlet.java:81)</span><br><span class="line">at org.springframework.web.servlet.mvc.ServletWrappingController.handleRequestInternal(ServletWrappingController.java:157)</span><br><span class="line">at org.springframework.cloud.netflix.zuul.web.ZuulController.handleRequest(ZuulController.java:44)</span><br><span class="line">at org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter.handle(SimpleControllerHandlerAdapter.java:50)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:635)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:317)</span><br><span class="line">at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127)</span><br><span class="line">at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:114)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at com.cmcc.cmct.gateway.auth.AuthenticationTokenProcessingFilter.doFilter(AuthenticationTokenProcessingFilter.java:47)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:64)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177)</span><br><span class="line">at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347)</span><br><span class="line">at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)</span><br><span class="line">at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478)</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: com.netflix.client.ClientException: null</span><br><span class="line">at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:118)</span><br><span class="line">at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:152)</span><br><span class="line">at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:49)</span><br><span class="line">at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302)</span><br><span class="line">at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:46)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)</span><br><span class="line">at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51)</span><br><span class="line">at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.subscribe(Observable.java:10247)</span><br><span class="line">at rx.Observable.subscribe(Observable.java:10214)</span><br><span class="line">at rx.internal.operators.BlockingOperatorToFuture.toFuture(BlockingOperatorToFuture.java:51)</span><br><span class="line">at rx.observables.BlockingObservable.toFuture(BlockingObservable.java:411)</span><br><span class="line">at com.netflix.hystrix.HystrixCommand.queue(HystrixCommand.java:378)</span><br><span class="line">at com.netflix.hystrix.HystrixCommand.execute(HystrixCommand.java:344)</span><br><span class="line">at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.forward(RibbonRoutingFilter.java:158)</span><br><span class="line">... 105 common frames omitted</span><br><span class="line">Caused by: java.lang.RuntimeException: java.net.UnknownHostException: xntest02.gzhl.quality: 未知的名称或服务</span><br><span class="line">at rx.exceptions.Exceptions.propagate(Exceptions.java:58)</span><br><span class="line">at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:464)</span><br><span class="line">at rx.observables.BlockingObservable.single(BlockingObservable.java:341)</span><br><span class="line">at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:112)</span><br><span class="line">... 167 common frames omitted</span><br><span class="line">Caused by: java.net.UnknownHostException: xntest02.gzhl.quality: 未知的名称或服务</span><br><span class="line">at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)</span><br><span class="line">at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:928)</span><br><span class="line">at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1323)</span><br><span class="line">at java.net.InetAddress.getAllByName0(InetAddress.java:1276)</span><br><span class="line">at java.net.InetAddress.getAllByName(InetAddress.java:1192)</span><br><span class="line">at java.net.InetAddress.getAllByName(InetAddress.java:1126)</span><br><span class="line">at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)</span><br><span class="line">at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)</span><br><span class="line">at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:359)</span><br><span class="line">at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:381)</span><br><span class="line">at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:237)</span><br><span class="line">at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:185)</span><br><span class="line">at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)</span><br><span class="line">at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:111)</span><br><span class="line">at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)</span><br><span class="line">at org.springframework.cloud.netflix.ribbon.apache.RibbonLoadBalancingHttpClient.execute(RibbonLoadBalancingHttpClient.java:82)</span><br><span class="line">at org.springframework.cloud.netflix.ribbon.apache.RibbonLoadBalancingHttpClient.execute(RibbonLoadBalancingHttpClient.java:42)</span><br><span class="line">at com.netflix.client.AbstractLoadBalancerAwareClient$1.call(AbstractLoadBalancerAwareClient.java:104)</span><br><span class="line">at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:303)</span><br><span class="line">at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:287)</span><br><span class="line">at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:231)</span><br><span class="line">at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:228)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)</span><br><span class="line">at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)</span><br><span class="line">at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:185)</span><br><span class="line">at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:180)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94)</span><br><span class="line">at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42)</span><br><span class="line">at rx.Observable.unsafeSubscribe(Observable.java:10151)</span><br><span class="line">at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:127)</span><br><span class="line">at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:73)</span><br><span class="line">at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:52)</span><br><span class="line">at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:79)</span><br><span class="line">at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45)</span><br><span class="line">at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276)</span><br><span class="line">at rx.Subscriber.setProducer(Subscriber.java:209)</span><br><span class="line">at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138)</span><br><span class="line">at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)</span><br><span class="line">at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)</span><br><span class="line">at rx.Observable.subscribe(Observable.java:10247)</span><br><span class="line">at rx.Observable.subscribe(Observable.java:10214)</span><br><span class="line">at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:444)</span><br><span class="line">... 169 common frames omitted</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>根据如下两部分的异常内容，通常会认为是<code>Ribbon</code>和<code>Hystrix</code>的超时问题。</p><p><strong>异常一：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.netflix.zuul.exception.ZuulException: Forwarding error</span><br><span class="line">    at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.handleException(RibbonRoutingFilter.java:189)</span><br><span class="line">    at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.forward(RibbonRoutingFilter.java:164)</span><br><span class="line">    at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.run(RibbonRoutingFilter.java:111)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p><strong>异常二：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: com.netflix.client.ClientException: null</span><br><span class="line">    at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:118)</span><br><span class="line">    at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:152)</span><br><span class="line">    at org.springframework.cloud.netflix.zuul.filters.route.support.AbstractRibbonCommand.run(AbstractRibbonCommand.java:49)</span><br><span class="line">    at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302)</span><br><span class="line">    at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298)</span><br></pre></td></tr></table></figure><p><strong>相应的解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ribbon.ConnectTimeout=60000</span><br><span class="line">ribbon.ReadTimeout=60000</span><br><span class="line"></span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=120000</span><br></pre></td></tr></table></figure><p><strong>然而</strong></p><p>不幸的是，我加了这两个超时配置之后，并没有改变zuul负载均衡转发异常。唯一改变的是：在每次异常发生时，请求的等待时间被大大延长。抓狂~~~~</p><p>通过多次的本地实验，我才开始对<strong>异常三</strong>产生了重视，内容如下：<br><strong>异常三：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.net.UnknownHostException: xntest02.gzhl.quality: 未知的名称或服务</span><br><span class="line">    at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)</span><br><span class="line">    at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:928)</span><br><span class="line">    at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1323)</span><br></pre></td></tr></table></figure><p>是的，重点在这里。尽管负载均衡器在启动的时候就发现了可以用于分担压力的三个节点，然而，这些节点信息都是Eureka提供的。我们的当地主机虽然获得了这些节点的<code>hostname</code>，却根本不知道如何去访问它们。</p><p><strong>zuul启动时获取的服务注册信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">07</span>:<span class="number">42.327</span> Gateway [main] INFO  c.n.l.DynamicServerListLoadBalancer - DynamicServerListLoadBalancer <span class="keyword">for</span> client CloudAPI initialized: </span><br><span class="line">DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=CloudAPI,current list of Servers=[xntest02.gzhl.quality:<span class="number">9000</span>, xntest03.gzhl.quality:<span class="number">9000</span>, xntest01.gzhl.quality:<span class="number">9000</span>],</span><br><span class="line">Load balancer stats=Zone stats: &#123;defaultzone=[Zone:defaultzone;</span><br><span class="line">Instance count:<span class="number">3</span>;</span><br><span class="line">Active connections count: <span class="number">0</span>;</span><br><span class="line">Circuit breaker tripped count: <span class="number">0</span>;</span><br><span class="line">Active connections per server: <span class="number">0.0</span>;]</span><br><span class="line">&#125;,</span><br><span class="line">Server stats: </span><br><span class="line">[[Server:xntest03.gzhl.quality:<span class="number">9000</span>;Zone:defaultZone;Total Requests:<span class="number">0</span>;Successive connection failure:<span class="number">0</span>;Total blackout seconds:<span class="number">0</span>;Last connection made:Thu Jan <span class="number">01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1970</span>;First connection made: Thu Jan <span class="number">01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1970</span>;Active Connections:<span class="number">0</span>;<span class="function">total failure count in <span class="title">last</span> <span class="params">(<span class="number">1000</span>)</span> msecs:0</span>;average resp time:<span class="number">0.0</span>;<span class="number">90</span> percentile resp time:<span class="number">0.0</span>;<span class="number">95</span> percentile resp time:<span class="number">0.0</span>;min resp time:<span class="number">0.0</span>;max resp time:<span class="number">0.0</span>;stddev resp time:<span class="number">0.0</span>]</span><br><span class="line">, [Server:xntest01.gzhl.quality:<span class="number">9000</span>;Zone:defaultZone;Total Requests:<span class="number">0</span>;Successive connection failure:<span class="number">0</span>;Total blackout seconds:<span class="number">0</span>;Last connection made:Thu Jan <span class="number">01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1970</span>;First connection made: Thu Jan <span class="number">01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1970</span>;Active Connections:<span class="number">0</span>;<span class="function">total failure count in <span class="title">last</span> <span class="params">(<span class="number">1000</span>)</span> msecs:0</span>;average resp time:<span class="number">0.0</span>;<span class="number">90</span> percentile resp time:<span class="number">0.0</span>;<span class="number">95</span> percentile resp time:<span class="number">0.0</span>;min resp time:<span class="number">0.0</span>;max resp time:<span class="number">0.0</span>;stddev resp time:<span class="number">0.0</span>]</span><br><span class="line">, [Server:xntest02.gzhl.quality:<span class="number">9000</span>;Zone:defaultZone;Total Requests:<span class="number">0</span>;Successive connection failure:<span class="number">0</span>;Total blackout seconds:<span class="number">0</span>;Last connection made:Thu Jan <span class="number">01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1970</span>;First connection made: Thu Jan <span class="number">01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1970</span>;Active Connections:<span class="number">0</span>;<span class="function">total failure count in <span class="title">last</span> <span class="params">(<span class="number">1000</span>)</span> msecs:0</span>;average resp time:<span class="number">0.0</span>;<span class="number">90</span> percentile resp time:<span class="number">0.0</span>;<span class="number">95</span> percentile resp time:<span class="number">0.0</span>;min resp time:<span class="number">0.0</span>;max resp time:<span class="number">0.0</span>;stddev resp time:<span class="number">0.0</span>]</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>看到这儿，解决方案也就出来了。那就是，确保每一个服务所在的服务器节点都能通过<code>hostname</code>和zuul网关互通。<br>从操作角度来说，就是要在每一台服务节点上配置其他所有服务节点的<code>hostname</code>，使得这些服务集群互通。</p><p>Liunx解决方案：<br>第一步 打开配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure><p>第二步 增加<code>服务</code>所在<code>主机ip</code>对应的<code>hostname</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.23.25.1 xntest01</span><br><span class="line">172.23.25.2 xntest02</span><br><span class="line">172.23.25.3 xntest03</span><br></pre></td></tr></table></figure><p><strong>大功告成~~~</strong></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zuul </tag>
            
            <tag> eureka </tag>
            
            <tag> micro service </tag>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务：Zuul代理转发</title>
      <link href="/posts/b778229b/"/>
      <url>/posts/b778229b/</url>
      <content type="html"><![CDATA[<h2 id="Zuul代理转发"><a href="#Zuul代理转发" class="headerlink" title="Zuul代理转发"></a>Zuul代理转发</h2><p>zuul代理转发的方式有两种：</p><p><strong>URL映射：</strong><code>优点</code>是不用对被代理的服务做任务修改，适合旧系统迁移到微服务架构时采用。过渡状态中，通常会保留旧代码继续使用，同时逐步将功能一点点迁移到新平台。旧功能的访问便可以采用这种方法，使得项目可以在用户毫无感知的情况下迁移到微服务架构。<code>缺点</code>是每增加一个服务就需要配置一条内容，不支持动态提供后端的服务。<br><strong>服务化映射：</strong>在实现微服务架构时，服务名与服务实例地址的关系在eureka server中已经存在了，所以只需要将Zuul注册到eureka server上去发现其他服务，就可以实现对serviceId的映射。</p><a id="more"></a><h4 id="URL映射"><a href="#URL映射" class="headerlink" title="URL映射"></a>URL映射</h4><h2 id="客户端存在context-path"><a href="#客户端存在context-path" class="headerlink" title="客户端存在context-path"></a>客户端存在context-path</h2><p><strong>客户端</strong><br>application.property配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=service-cloudapp</span><br><span class="line"></span><br><span class="line">server.context-path=/SPLD</span><br></pre></td></tr></table></figure><p>说明: 直接访问路径为——<code>http://ip:port/SPLD/api</code></p><p><strong>zuul</strong><br>application.property配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注册Eureka服务发现</span><br><span class="line">eureka.client.serviceUrl.defaultZone: http://localhost:8060/eureka/</span><br><span class="line"></span><br><span class="line">#转发</span><br><span class="line">zuul.routes.app.path=/SPLD/**</span><br><span class="line">zuul.routes.app.serviceId=service-cloudapp</span><br></pre></td></tr></table></figure><p>那么访问路径是：<code>http://ip:port/SPLD/SPLD/api</code></p><p>如何去掉重复的前缀呢？<br>可以在zuul中，路由后面增加配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zuul.routes.app.stripPrefix=false</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>当<code>stripPrefix=true</code>的时候，<strong>代理前缀</strong>默认会从请求路径中<strong>移除</strong>。访问<code>http://zuul-ip:port/SPLD/api</code>重定向到<code>http://spld-ip:port/api</code>  </li><li>当<code>stripPrefix=false</code>的时候，会<strong>保留代理前缀</strong>。访问<code>http://zuul-ip:port/SPLD/api</code>会重定向到<code>http://spld-ip:port/SPLD/api</code>。 </li></ul><p>参考文章：<br><a href="http://www.cnblogs.com/ityouknow/p/6944096.html" target="_blank" rel="noopener">springcloud(十)：服务网关zuul</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zuul </tag>
            
            <tag> micro service </tag>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Liunx：常用命令</title>
      <link href="/posts/cbdebe31/"/>
      <url>/posts/cbdebe31/</url>
      <content type="html"><![CDATA[<h2 id="SCP-文件传输"><a href="#SCP-文件传输" class="headerlink" title="SCP-文件传输"></a>SCP-文件传输</h2><h3 id="从服务器下载文件"><a href="#从服务器下载文件" class="headerlink" title="从服务器下载文件"></a>从服务器下载文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp username@servername:/remote_path/filename ~/local_destination</span><br></pre></td></tr></table></figure><h3 id="从服务器下载整个目录"><a href="#从服务器下载整个目录" class="headerlink" title="从服务器下载整个目录"></a>从服务器下载整个目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r username@servername:/remote_path/remote_dir/ ~/local_destination</span><br></pre></td></tr></table></figure><h3 id="上传本地文件到服务器"><a href="#上传本地文件到服务器" class="headerlink" title="上传本地文件到服务器"></a>上传本地文件到服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp ~/local_path/local_filename username@servername:/remote_path</span><br></pre></td></tr></table></figure><h3 id="上传目录到服务器"><a href="#上传目录到服务器" class="headerlink" title="上传目录到服务器"></a>上传目录到服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp  -r ~/local_dir username@servername:/remote_path/remote_dir</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8010180     1027572      454540       74152     6528068     6504456</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p><strong>total:</strong>总计物理内存的大小。<br><strong>used:</strong>已使用多大。<br><strong>free:</strong>可用有多少。<br><strong>Shared:</strong>多个进程共享的内存总额。<br><strong>Buffers/cached:</strong>磁盘缓存的大小。 </p><p><code>Mem</code>的<code>used/free</code>是从<code>OS</code>的角度来看，因为对于<code>OS</code>，<code>buffers/cached</code>都是属于被使用的</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><ol><li>登录账户后，输入<code>passwd</code></li><li>输入一遍旧密码，输入两遍新密码，密码不能太简单</li></ol><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><p>通常数据文件会和应用部署所在系统盘分开。此时，为了既能保持整体一致性，又不会占用系统盘资源，通常会在应用部署的文件夹下建立一个指向数据盘的软连接。</p><p><strong>命令：</strong>ln -s abc(源文件) efg(目标快捷方式)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s /data/upload/ ./upload</span><br></pre></td></tr></table></figure><p><strong>效果：</strong>当前目录产生如下文件目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root       13 6月  20 15:35 upload -&gt; /data/upload/</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>必须使用绝对路径，否则会出现<code>符号连接的层数过多</code>的错误。</p><h2 id="查看进程的完整路径"><a href="#查看进程的完整路径" class="headerlink" title="查看进程的完整路径"></a>查看进程的完整路径</h2><p>在使用<code>ps -ef</code>查看当前进程时，看到的路径通常是不完整的，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看命令</span><br><span class="line">ps -aux |grep nginx</span><br><span class="line"></span><br><span class="line">#显示内容</span><br><span class="line">root     12996     1  0 19:44 ?        00:00:00 nginx: master process ../sbin/nginx</span><br></pre></td></tr></table></figure><p>其中，最后的<code>../sbin/nginx</code>就是启动进程的命令。那么如何才能查看到完整路径呢？</p><p>linux为每一个启动的进程都建立了一个文件夹，目录位于<code>/proc/</code>，以上面的进程为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#输入命令</span><br><span class="line">cd /proc/12996</span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line">#查看结果</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  30 20:04 cwd -&gt; /usr/local/nginx-1.15.2/conf</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  30 20:04 exe -&gt; /usr/local/nginx-1.15.2/sbin/nginx</span><br></pre></td></tr></table></figure><p>由此可见，完整路径为：<code>/usr/local/nginx-1.15.2/sbin/nginx</code></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库：MyBatis常用语法</title>
      <link href="/posts/5a838215/"/>
      <url>/posts/5a838215/</url>
      <content type="html"><![CDATA[<h2 id="Else判断分支"><a href="#Else判断分支" class="headerlink" title="Else判断分支"></a>Else判断分支</h2><p>使用MyBatis写动态SQL查询相比Hiberntate是非常方便的。select不仅能够根据mapper接口中的返回值自动匹配</p><p>查询selectOne还是selectList，而且在查询中还可以灵活的定制查询的方式，添加if 或者 choose等标签进行查询。mybaits中没有else要用“chose when otherwise”代替</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--批量插入用户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getItems"</span> <span class="attr">parameterType</span>=<span class="string">"com.ipro.shopping.to.IntegerEntity"</span> <span class="attr">resultType</span>=<span class="string">"itemsType"</span>&gt;</span>  </span><br><span class="line">   select * from itemsType  </span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!--方式一使用choose的方式查询--&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- &lt;choose&gt;  </span></span><br><span class="line"><span class="comment">         &lt;when test="parentId !=0 "&gt;parentTypeId=#&#123;parentId&#125;&lt;/when&gt;  </span></span><br><span class="line"><span class="comment">         &lt;when test="parentId==0"&gt;parentTypeId is null&lt;/when&gt;  </span></span><br><span class="line"><span class="comment">      &lt;/choose&gt; --&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!--方式二使用if的方式查询--&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"parentId!=0"</span>&gt;</span>  </span><br><span class="line">         parentTypeId=#&#123;parentId&#125;  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"parentId==0"</span>&gt;</span>  </span><br><span class="line">        parentTypeId is null  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="导出表结构和数据"><a href="#导出表结构和数据" class="headerlink" title="导出表结构和数据"></a>导出表结构和数据</h2><p>使用<code>mysqldump</code>命令，具体用法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u用戶名 -p密码 -d 数据库名 表名 &gt; 脚本名;</span><br></pre></td></tr></table></figure><p>导出整个数据库结构和数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456 database &gt; dump.sql</span><br></pre></td></tr></table></figure><p>导出单个数据表结构和数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  database table &gt; dump.sql</span><br></pre></td></tr></table></figure><p>导出整个数据库结构（不包含数据）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  -d database &gt; dump.sql</span><br></pre></td></tr></table></figure><p>导出单个数据表结构（不包含数据）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  -d database table &gt; dump.sql</span><br></pre></td></tr></table></figure><h3 id="可能异常"><a href="#可能异常" class="headerlink" title="可能异常"></a>可能异常</h3><p>可能在执行导出命令时，会遇到如下异常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump: Error: &apos;Got error 28 from storage engine&apos; when trying to dump tablespaces</span><br><span class="line">mysqldump: Couldn&apos;t execute &apos;show fields from `consumption`&apos;: Got error 28 from storage engine (1030)</span><br></pre></td></tr></table></figure><p><strong>原因</strong> 是系统空间不足，可以清理一下缓存。</p><h2 id="数据库外键关联"><a href="#数据库外键关联" class="headerlink" title="数据库外键关联"></a>数据库外键关联</h2><p>外键关联有四种模式，分别如下：</p><p><strong>CASCADE:</strong> 从父表中删除或更新对应的行，同时自动的删除或更新子表中匹配的行。<code>ON DELETE CANSCADE</code>和<code>ON UPDATE CANSCADE</code>都被<code>InnoDB</code>所支持。</p><p><strong>SET NULL:</strong> 从父表中删除或更新对应的行，同时将子表中的外键列设为空。注意，这些在外键列没有被设为<code>NOT NULL</code>时才有效。<code>ON DELETE SET NULL</code>和<code>ON UPDATE SET SET NULL</code>都被<code>InnoDB</code>所支持。</p><p><strong>NO ACTION:</strong> <code>InnoDB</code>拒绝删除或者更新父表。</p><p><strong>RESTRICT:</strong> 拒绝删除或者更新父表。指定<code>RESTRICT</code>（或者<code>NO ACTION</code>）和忽略<code>ON DELETE</code>或者<code>ON UPDATE</code>选项的效果是一样的</p><h2 id="按天分组查询"><a href="#按天分组查询" class="headerlink" title="按天分组查询"></a>按天分组查询</h2><table><thead><tr><th>username</th><th style="text-align:center">create_time</th></tr></thead><tbody><tr><td>张三</td><td style="text-align:center">2018-03-13 09:48:34</td></tr><tr><td>李四</td><td style="text-align:center">2018-03-14 09:24:32</td></tr></tbody></table><p>查询某天：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT( create_time, &quot;%Y-%m-%d) as date, COUNT( * ) as count</span><br><span class="line">FROM test</span><br><span class="line">GROUP BY DATE_FORMAT( create_time, &quot;%Y-%m-%d)</span><br></pre></td></tr></table></figure><p>结果：</p><table><thead><tr><th>date</th><th style="text-align:center">count</th></tr></thead><tbody><tr><td>2018-03-13</td><td style="text-align:center">1</td></tr><tr><td>2018-03-14</td><td style="text-align:center">1</td></tr></tbody></table><p>如果想要查询某时的统计信息，可以修改<code>DATE_FORMAT</code>内容：</p><p><code>create_time, &quot;%Y-%m-%d %H&quot;</code></p><p>依次类推，其实就是对<code>create_time</code>进行处理，然后再对处理后的数据分组。</p><h2 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">like CONCAT(&apos;%&apos;, #&#123;port&#125;, &apos;%&apos;)</span><br></pre></td></tr></table></figure><h2 id="插入数据后返回id"><a href="#插入数据后返回id" class="headerlink" title="插入数据后返回id"></a>插入数据后返回id</h2><p><code>&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.cmcc.Bean&quot;&gt;</code>标签最后加入<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code>。新标签如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.cmcc.Bean&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quartz：Cron表达式详解</title>
      <link href="/posts/f507bee4/"/>
      <url>/posts/f507bee4/</url>
      <content type="html"><![CDATA[<p>CronExpression：用于配置cronTrigger的实例，由七个子表达式组成。这些表达式之间用空格分隔。</p><ol><li>Seconds（秒）</li><li>Minutes（分）</li><li>Hours（小时）</li><li>Day-of-Month（天）</li><li>Month（月）</li><li>Day-of-Week（周）</li><li>Year（年）</li></ol><p>例：”0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。</p><a id="more"></a><p>个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成”MON-FRI”，”MON,WED,FRI”，甚至”MON-WED,SAT”。</p><h2 id="子表达式范围"><a href="#子表达式范围" class="headerlink" title="子表达式范围"></a>子表达式范围</h2><ol><li>Seconds (0~59)</li><li>Minutes (0~59)</li><li>Hours (0~23)</li><li>Day-of-Month (1~31,但是要注意有些月份没有31天)</li><li>Month (0~11，或者”JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC”)</li><li>Day-of-Week (1~7,1=SUN 或者”SUN, MON, TUE, WED, THU, FRI, SAT”)</li><li>Year (1970~2099)</li></ol><table><thead><tr><th>字段名</th><th style="text-align:center">允许的值</th><th style="text-align:center">允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td>分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td>小时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td></tr><tr><td>日</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W C</td></tr><tr><td>月</td><td style="text-align:center">1-12 or JAN-DEC</td><td style="text-align:center">, - * /</td></tr><tr><td>周几</td><td style="text-align:center">1-7 or SUN-SAT</td><td style="text-align:center">, - * ? / L C #</td></tr><tr><td>年(可选字段)</td><td style="text-align:center">empty</td><td style="text-align:center">1970-2099 , - * /</td></tr></tbody></table><h2 id="字符含义"><a href="#字符含义" class="headerlink" title="字符含义"></a>字符含义</h2><p>* ：代表所有可能的值。因此，“*”在Month中表示每个月，在Day-of-Month中表示每天，在Hours表示每小时</p><p>- ：表示指定范围。</p><p>, ：表示列出枚举值。例如：在Minutes子表达式中，“5,20”表示在5分钟和20分钟触发。</p><p>/ ：被用于指定增量。例如：在Minutes子表达式中，“0/15”表示从0分钟开始，每15分钟执行一次。”3/20”表示从第三分钟开始，每20分钟执行一次。和”3,23,43”（表示第3，23，43分钟触发）的含义一样。</p><p>? ：用在Day-of-Month和Day-of-Week中，指“没有具体的值”。当两个子表达式其中一个被指定了值以后，为了避免冲突，需要将另外一个的值设为“?”。例如：想在每月20日触发调度，不管20号是星期几，只能用如下写法：0 0 0 20 <em> ?，其中最后以为只能用“?”，而不能用“</em>”。</p><p>L ：用在day-of-month和day-of-week字串中。它是单词“last”的缩写。它在两个子表达式中的含义是不同的。<br>在day-of-month中，“L”表示一个月的最后一天，一月31号，3月30号。<br>在day-of-week中，“L”表示一个星期的最后一天，也就是“7”或者“SAT”<br>如果“L”前有具体内容，它就有其他的含义了。例如：“6L”表示这个月的倒数第六天。“FRIL”表示这个月的最后一个星期五。<br>注意：在使用“L”参数时，不要指定列表或者范围，这样会出现问题。</p><p>W ：“Weekday”的缩写。只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日，即最后一个星期五。</p><p># ：只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3” or “FRI#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。</p><h2 id="表达式例子"><a href="#表达式例子" class="headerlink" title="表达式例子"></a>表达式例子</h2><table><thead><tr><th>表达式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>0 <em> </em> <em> </em> ?</td><td style="text-align:center">每1分钟触发一次</td></tr><tr><td>0 0 <em> </em> * ?</td><td style="text-align:center">每天每1小时触发一次</td></tr><tr><td>0 0 10 <em> </em> ?</td><td style="text-align:center">每天10点触发一次</td></tr><tr><td>0 <em> 14 </em> * ?</td><td style="text-align:center">在每天下午2点到下午2:59期间的每1分钟触发 </td></tr><tr><td>0 30 9 1 * ?</td><td style="text-align:center">每月1号上午9点半</td></tr><tr><td>0 15 10 15 * ?</td><td style="text-align:center">每月15日上午10:15触发</td></tr><tr><td><em>/5 </em> <em> </em> * ?</td><td style="text-align:center">每隔5秒执行一次</td></tr><tr><td>0 <em>/1 </em> <em> </em> ?</td><td style="text-align:center">每隔1分钟执行一次</td></tr><tr><td>0 0 5-15 <em> </em> ?</td><td style="text-align:center">每天5-15点整点触发</td></tr><tr><td>0 0/3 <em> </em> * ?</td><td style="text-align:center">每三分钟触发一次</td></tr><tr><td>0 0-5 14 <em> </em> ?</td><td style="text-align:center">在每天下午2点到下午2:05期间的每1分钟触发 </td></tr><tr><td>0 0/5 14 <em> </em> ?</td><td style="text-align:center">在每天下午2点到下午2:55期间的每5分钟触发</td></tr><tr><td>0 0/5 14,18 <em> </em> ?</td><td style="text-align:center">在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</td></tr><tr><td>0 0/30 9-17 <em> </em> ?</td><td style="text-align:center">朝九晚五工作时间内每半小时</td></tr><tr><td>0 0 10,14,16 <em> </em> ?</td><td style="text-align:center">每天上午10点，下午2点，4点 </td></tr><tr><td>0 0 12 ? * WED</td><td style="text-align:center">表示每个星期三中午12点</td></tr><tr><td>0 0 17 ? * TUES,THUR,SAT</td><td style="text-align:center">每周二、四、六下午五点</td></tr><tr><td>0 10,44 14 ? 3 WED</td><td style="text-align:center">每年三月的星期三的下午2:10和2:44触发 </td></tr><tr><td>0 15 10 ? * MON-FRI</td><td style="text-align:center">周一至周五的上午10:15触发</td></tr><tr><td>0 0 23 L * ?</td><td style="text-align:center">每月最后一天23点执行一次</td></tr><tr><td>0 15 10 L * ?</td><td style="text-align:center">每月最后一日的上午10:15触发 </td></tr><tr><td>0 15 10 ? * 6L</td><td style="text-align:center">每月的最后一个星期五上午10:15触发 </td></tr><tr><td>0 15 10 <em> </em> ? 2005</td><td style="text-align:center">2005年的每天上午10:15触发 </td></tr><tr><td>0 15 10 ? * 6L 2002-2005</td><td style="text-align:center">2002年至2005年的每月的最后一个星期五上午10:15触发 </td></tr><tr><td>0 15 10 ? * 6#3</td><td style="text-align:center">每月的第三个星期五上午10:15触发</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Quartz </tag>
            
            <tag> 持久化 </tag>
            
            <tag> 对象注入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo：Nginx独立部署方法</title>
      <link href="/posts/3a8571de/"/>
      <url>/posts/3a8571de/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自己的生产环境中部署hexo静态博客，通常有两种方法：<br><strong>nohup命令</strong>：通过<code>nohup</code>执行<code>hexo s</code>实现。由于hexo s是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题，不建议使用；<br><strong>Nginx服务器</strong>：通过<code>nginx</code>部署静态资源，将本地调试好的hexo工程打包生成的<code>public</code>目录部署到<code>nginx</code>上。<code>nginx</code>性能好，访问速度快。</p><a id="more"></a> <h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>处理二级目录</strong>：当生产环境中，静态博客部署在二级目录下（如：“http://域名(ip)/blog”这种情况），需要修改hexo工程下的_config.yml配置文件，否则打包生成的css、js文件目录会缺失（默认在根目录），导致无法加载样式。一般修改<code>root</code>和<code>url</code>,增加二级目录</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' </span></span><br><span class="line"><span class="comment">## and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://yoursite.com/blog</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p><strong>部署在根目录无需处理</strong></p><p><strong>打包</strong>：通常在调试环境无需打包，修改后使用<code>hexo s</code>，即可生效，可以直接在本地查看效果。但是，以静态资源的方式部署需要打包生成静态资源，命令为：<code>hexo generate</code>。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="配置静态资源路由"><a href="#配置静态资源路由" class="headerlink" title="配置静态资源路由"></a>配置静态资源路由</h3><p><strong>示例</strong>：hexo打包完成之后，以静态资源的方式部署到nginx，增加一个<code>location</code>模块。路由的细节有两种：<code>root</code>和<code>alias</code>，主要区别就是怎么解析location后面的uri。以下代码以<code>root</code>为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /blog &#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>root规则:</strong> 以上的示例，说明访问的实际路由为：html/blog/index.html</p><p><strong>alias规则:</strong> 同样的路径，alias需要按下面这么写，location后面的blog不会接到alias后面，而且alias指定的目录名后面一定要加上”/“。（<code>^~</code>表示uri以某个常规字符串开头，用于匹配url路径（而且不对url做编码处理，例如请求/static/20%/aa，可以被规则^~ /static/ /aa 匹配到（注意是空格））。下面是alias示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ /blog/ &#123;</span><br><span class="line">alias html/blog/;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><ul><li>启动：nginx</li><li>停止：nginx -s stop</li><li>重启：nginx -s restart</li><li>指定配置文件启动：nginx -c 路径 </li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="http:\\www.baidu.com" target="_blank" rel="noopener">nginx之location（root/alias）</a></li></ol>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo：Github部署站点的SEO优化教程</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      <content type="html"><![CDATA[<p>个人博客搭建完成，就算在互联网的世界里安了一个家。从阿里云的万网申请到了域名，我们的家也就有了门牌号。然而，要在茫茫人海中被人发现，仅仅靠口口相传是不够的。我们需要在黄页上登记自己的住址和成员，这样，有缘人才能登门拜访。<br><a id="more"></a></p><h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="1-生成sitemap"><a href="#1-生成sitemap" class="headerlink" title="1.生成sitemap"></a>1.生成sitemap</h2><p>针对百度和谷歌，分别有两种hexo插件，hexo-generator-sitemap是传统的sitemap，可供谷歌使用；hexo-generator-baidu-sitemap则是针对百度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save-dev</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save-dev</span><br></pre></td></tr></table></figure><p>安装完成后，重启hexo，执行<strong>hexo g</strong>后，在public目录下生成对应的xml文件。本地可以通过<code>http://127.0.0.4000/sitemap.xml</code>和 <code>http://127.0.0.4000/baidusitemap.xml</code>访问到sitemap文件。</p><h2 id="2-注册百度站长平台"><a href="#2-注册百度站长平台" class="headerlink" title="2.注册百度站长平台"></a>2.注册百度站长平台</h2><p>有百度账号即可</p><h2 id="3-添加个人站点"><a href="#3-添加个人站点" class="headerlink" title="3.添加个人站点"></a>3.添加个人站点</h2><p>进入站点管理，添加网站，主要障碍在第二步的<strong>验证</strong>，方式有三：文件、html标签和cname。由于hexo会在生成编译文件的过程中，修改html文件内容，导致百度验证失败，因此，不建议再踩一遍这个坑。</p><p>由于域名是我在万网上注册的，所以选择cname的方式。过程如下：</p><ul><li>进入万网云解析管理平台；</li><li>添加解析&gt;记录类型（CNAME），填写表单，两项必填：<ul><li><strong>主机</strong>：就是他给你的带有自身网站后缀的域名</li><li><strong>记录值</strong>：ziyuan.baidu.com</li></ul></li></ul><h2 id="4-提交sitemap"><a href="#4-提交sitemap" class="headerlink" title="4.提交sitemap"></a>4.提交sitemap</h2><p>回到链接提交处，选择自己的站点网址。找到自动提交，选择sitemap，按照提示的格式添加自己的sitemap文件</p><h2 id="5-新增蜘蛛协议"><a href="#5-新增蜘蛛协议" class="headerlink" title="5.新增蜘蛛协议"></a>5.新增蜘蛛协议</h2><p>新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: * Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://dadroid.cn/sitemap.xml</span><br><span class="line">Sitemap: http://dadroid.cn/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>然后去百度站长平台检测<code>robots</code>文件是否生效。</p><h2 id="However"><a href="#However" class="headerlink" title="However"></a>However</h2><p>挂了好几天，发现百度依然收录不了我的站点，登录平台查看<code>抓取诊断</code>-&gt;<code>抓取一次</code>，错误信息如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 03 May 2018 05:57:37 GMT</span><br><span class="line">Via: 1.1 varnish</span><br><span class="line">Connection: close</span><br><span class="line">X-Served-By: cache-hnd18744-HND</span><br><span class="line">X-Cache: MISS</span><br><span class="line">X-Cache-Hits: 0</span><br><span class="line">X-Timer: S1525327058.780403,VS0,VE113</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Fastly-Request-ID: 7333aaaa3853b41672517dffa1a85e843dcbcdb4</span><br></pre></td></tr></table></figure><p>可以看出该错误是<code>拒绝访问</code>，根据百度提供的信息可知</p><blockquote><p>【访问遭拒绝】<br>一般情况下，百度会通过跟踪网页间的链接来查找内容。百度spider必须能够访问某个网页才能抓取该网页。如果您意外地看到了“访问遭拒”错误，可能是由于以下几种原因导致的：<br>（1）百度spider无法访问您网站上的网址，因为您网站上的所有或部分内容要求用户登录后才能查看。<br>（2）您的服务器要求用户使用代理进行身份验证，或者您的托管服务提供商阻止百度spider访问您的网站。</p></blockquote><p>说明我们托管在<code>github pages</code>上的博客禁止百度爬虫的访问。那么我们有什么办法能让百度收录我们的页面呢？</p><ul><li>托管在国内平台，如coding</li><li>采用主动/手动提交链接</li></ul><p>由于coding绑定自定义域名免费模式会被拦截，显示coding的广告，既影响爬虫抓取站点内容，也影响美观，因此尝试过后便放弃了。下面介绍使用hexo自动提交链接的插件。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>注册百度站长工具，然后在工具-&gt;网页抓取-&gt;链接提交里找到你的密匙。</p><h3 id="hexo-baidu-url-submit"><a href="#hexo-baidu-url-submit" class="headerlink" title="hexo-baidu-url-submit"></a>hexo-baidu-url-submit</h3><p>首先，在Hexo根目录下，安装本插件：<br><code>npm install hexo-baidu-url-submit --save</code></p><p>然后，同样在根目录下，把以下内容配置到_config.yml文件中:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 ## 提交最新的一个链接</span><br><span class="line">  host: www.hui-wang.info ## 在百度站长平台中注册的域名</span><br><span class="line">  token: your_token ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p>其次，记得查看_config.ym文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: http://www.dadroid.cn</span><br><span class="line">root: /</span><br><span class="line">permalink:</span><br></pre></td></tr></table></figure><p>最后，加入新的deployer:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git ## 这是我原来的deployer</span><br><span class="line">- type: baidu_url_submitter ## 这是新加的</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>新链接的产生，<code>hexo generate</code>会产生一个文本文件，里面包含最新的链接</li><li>新链接的提交，<code>hexo deploy</code>会从上述文件中读取链接，提交至百度搜索引擎</li></ul><h1 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h1><p>步骤1——5与百度大同小异，以下介绍一些不同点：</p><h2 id="1-注册Google-Search-Console"><a href="#1-注册Google-Search-Console" class="headerlink" title="1.注册Google Search Console"></a>1.注册Google Search Console</h2><p>链接：<a href="https://www.google.com/webmasters/" target="_blank" rel="noopener">https://www.google.com/webmasters/</a></p><h2 id="2-抓取方式"><a href="#2-抓取方式" class="headerlink" title="2.抓取方式"></a>2.抓取方式</h2><p>完成robost检测后，点击左侧的<code>Google抓取方式</code>。</p><p>在这里我们填上我们需要抓取的url，不填这表示抓取首页，抓取方式可以选择桌面，智能手机，自行根据需要选择。填好url之后，点击抓取。<br>然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。</p><p>提交完成后，提交至索引，根据提示操作就可以了</p><h1 id="hexo优化"><a href="#hexo优化" class="headerlink" title="hexo优化"></a>hexo优化</h1><h2 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h2><p>Hexo默认的文章链接形式是一个四级url——<code>domain/year/month/day/postname</code>，可能造成url过长，对搜索引擎是十分不友好。我们可以改成<code>domain/postname</code>的形式，编辑站点_config.yml文件，修改permalink字段改为<code>permalink: :title.html</code>即可。</p><h2 id="keywords-和-description"><a href="#keywords-和-description" class="headerlink" title="keywords 和 description"></a>keywords 和 description</h2><p>在hexo工程根目录下的<code>\scaffolds\post.md</code>中添加如下代码，用于生成的文章中添加关键字和描述。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keywords:</span><br><span class="line">description:</span><br></pre></td></tr></table></figure><h2 id="给出站链接添加-“nofollow”-标签"><a href="#给出站链接添加-“nofollow”-标签" class="headerlink" title="给出站链接添加 “nofollow” 标签"></a>给出站链接添加 “nofollow” 标签</h2><p>网络爬虫可能在搜索当前页面的所有链接时，跳到别的网站回不来了。因此，需要<code>nofollow</code>标签发挥作用。</p><p><code>nofollow</code>标签是由<strong>谷歌</strong>领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用<code>nofollow</code>标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上带有<code>nofollow</code>属性的任何出站链接，以减少垃圾链接的分散网站权重。</p><p>Hexo的Next主题需要改以下几个地方：</p><ol><li>找到<code>footer.swig</code>，路径在<code>your-hexo-site\themes\next\layout\_partials</code>，将下面代码中的<code>a标签</code>加上<code>rel=&quot;external nofollow&quot;</code>属性；</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a  class=&quot;theme-link&quot;  href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改<code>sidebar.swig</code>文件，路径在<code>your-hexo-site\themes\next\layout_macro</code>，将下面代码中的<code>a标签</code>加上<code>rel=&quot;external nofollow&quot;</code>属性；</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="首页title的优化"><a href="#首页title的优化" class="headerlink" title="首页title的优化"></a>首页title的优化</h2><p>更改<code>index.swig</code>文件，文件路径是<code>your-hexo-site\themes\next\layout</code>，将下面代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quartz：基本用法总结</title>
      <link href="/posts/f6df2318/"/>
      <url>/posts/f6df2318/</url>
      <content type="html"><![CDATA[<p>OpenSymphony所提供的Quartz是任务调度领域享誉盛名的开源框架。Spring提供了集成Quartz的功能，可以让开发人员以更面向Spring的方式创建基于Quartz的任务调度应用。任务调度本身设计多线程并发、运行时间规则制定及解析、运行现场保持与恢复、线程池维护等诸多方面的工作。如果以自定义线程池的原始方法开发，难点很大。<br><a id="more"></a></p><h2 id="1-普通JAVA任务"><a href="#1-普通JAVA任务" class="headerlink" title="1.普通JAVA任务"></a>1.普通JAVA任务</h2><p>启动基本的Quartz任务包含一下流程：</p><ol><li>创建任务类：实现Job接口的void execute(JobExecutionContext context)方法，定义被执行任务的执行逻辑；</li><li>生成JobDetail对象：通过加载任务类（不是实例）来绑定任务逻辑与任务信息；</li><li>生成Trigger对象：定时器的触发时间有两种方式可以定义，分别是CronSchedule和simpleSchedule()。前者使用正则表达式，后者则是简单封装后的定时器。</li><li>获取Scheduler对象：通过<code>StdSchedulerFactory</code>工厂方法初始化scheduler对象，把任务和定时器绑定在一起，并启动任务。</li></ol><h3 id="完整实例代码"><a href="#完整实例代码" class="headerlink" title="完整实例代码"></a>完整实例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RAMQuartz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RAMQuartz.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">    <span class="comment">//创建scheduler</span></span><br><span class="line">        SchedulerFactory sf = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">        Scheduler scheduler = sf.getScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个JobDetail</span></span><br><span class="line"><span class="comment">//定义Job类为RAMJob类，这是真正的执行逻辑所在</span></span><br><span class="line">        JobDetail jb = JobBuilder.newJob(RAMJob1.class) </span><br><span class="line">                .withDescription(<span class="string">"this is a ram job"</span>)</span><br><span class="line">                .withIdentity(<span class="string">"ramJob"</span>, <span class="string">"ramGroup"</span>)<span class="comment">//定义name/group</span></span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//通过JobDataMap传递参数</span></span><br><span class="line">        jb.getJobDataMap().put(<span class="string">"Test"</span>, <span class="string">"This is test parameter value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() + <span class="number">3</span>*<span class="number">1000L</span>;</span><br><span class="line">        Date startTime = <span class="keyword">new</span> Date(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Trigger</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withDescription(<span class="string">""</span>)</span><br><span class="line">                .withIdentity(<span class="string">"ramTrigger"</span>, <span class="string">"ramTriggerGroup"</span>)<span class="comment">//定义name/group</span></span><br><span class="line">                .startAt(startTime)<span class="comment">//加入scheduler后，在指定时间启动</span></span><br><span class="line">                <span class="comment">//使用CronTrigger</span></span><br><span class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/2 * * * * ?"</span>))</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//绑定任务和定时器到调度器</span></span><br><span class="line">        scheduler.scheduleJob(jb,trigger);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">        logger.info(<span class="string">"启动时间 ： "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDataMap;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RAMJob1</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RAMJob.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JobDataMap dataMap = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">            String str = dataMap.getString(<span class="string">"Test"</span>);</span><br><span class="line">            logger.info(<span class="string">"Quartz dataMap : "</span> + <span class="keyword">new</span> Date() + <span class="string">"\n"</span> + str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-对象注入"><a href="#2-对象注入" class="headerlink" title="2.对象注入"></a>2.对象注入</h2><p>在Spring的WEB应用中使用定时器，通常都会用到spring的特性——对象注入。前面的代码虽然能够很好地执行简单的定时器任务，但是遇到复杂的执行逻辑（如数据库读写等），就不能应付了。</p><p>下面代码可以看出，任务2需要执行myBatis的数据库插入语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RAMJob2</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestQuartzMapper testQuartzMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RAMJob.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testQuartzMapper.insertSelective(testQuartz);</span><br><span class="line">            logger.info(<span class="string">"Insert MyBatis Success!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个业务逻辑，就不得不注入对象。如果仍然延用上面的方法，我们会发现执行的时候，testQuartzMapper的对象为null，结果自然毫无悬念地不断报错。</p><p>如何为我们的定时器注入Spring的对象，下面介绍一下思路：</p><ol><li>自定义<code>JobFactory</code>工厂方法，扩展<code>AdaptableJobFactory</code>，重写其<code>createJobInstance</code>方法；</li><li>声明<code>SchedulerFactoryBean</code>，传入自定义的<code>JobFactory</code>工厂方法；</li><li>通过新的<code>SchedulerFactoryBean</code>获取<code>scheduler</code>实例，用注入的方式在需要的地方使用。</li></ol><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.spi.TriggerFiredBundle;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.AdaptableJobFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJobFactory</span> <span class="keyword">extends</span> <span class="title">AdaptableJobFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AutowireCapableBeanFactory capableBeanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createJobInstance</span><span class="params">(TriggerFiredBundle bundle)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法</span></span><br><span class="line">        Object jobInstance = <span class="keyword">super</span>.createJobInstance(bundle);</span><br><span class="line">        <span class="comment">// 进行注入</span></span><br><span class="line">        capableBeanFactory.autowireBean(jobInstance);</span><br><span class="line">        <span class="keyword">return</span> jobInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyJobFactory myJobFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">schedulerFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SchedulerFactoryBean factory = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载quartz数据源配置</span></span><br><span class="line">        factory.setQuartzProperties(quartzProperties());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义Job Factory，用于Spring注入</span></span><br><span class="line">        factory.setJobFactory(myJobFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SchedulerException </span>&#123;</span><br><span class="line">        Scheduler scheduler = schedulerFactoryBean().getScheduler();</span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="keyword">return</span> scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Spring简单任务"><a href="#3-Spring简单任务" class="headerlink" title="3.Spring简单任务"></a>3.Spring简单任务</h3><p>Spring对Quartz进行了封装，方便开发者调用。下面以Spring Boot为例，介绍一下简单任务在Spring的执行方式。</p><h4 id="任务类定义"><a href="#任务类定义" class="headerlink" title="任务类定义"></a>任务类定义</h4><p>仔细观察可以发现，与普通Java任务的区别在于使用了@Component和@EnableScheduling的注释，相应的，就不用声明<code>implements Job</code>，以及重写<code>execute</code>方法。这是Spring提供的一种便利。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringJob</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WriteService writeService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myJobBusinessMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"MyFirstExerciseJob哇被触发了哈哈哈哈哈"</span>);</span><br><span class="line">        writeService.writeMSG(<span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置JobDetail和Trigger的Bean"><a href="#配置JobDetail和Trigger的Bean" class="headerlink" title="配置JobDetail和Trigger的Bean"></a>配置JobDetail和Trigger的Bean</h2><p><code>MethodInvokingJobDetailFactoryBean</code>是Spring提供的JobDetail工厂方法，使用它可以快速地定义JobDetail。然而，缺点是生成的任务无法持久化保存，也就是说，无法管理任务的启动、暂停、恢复、停止等操作。<br><code>CronTriggerFactoryBean</code>为表达式型触发器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzJobConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法调用任务明细工厂Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"SpringJobBean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInvokingJobDetailFactoryBean <span class="title">myFirstExerciseJobBean</span><span class="params">(SpringJob springJob)</span> </span>&#123;</span><br><span class="line">        MethodInvokingJobDetailFactoryBean jobDetail = <span class="keyword">new</span> MethodInvokingJobDetailFactoryBean();</span><br><span class="line">        jobDetail.setConcurrent(<span class="keyword">false</span>); <span class="comment">// 是否并发</span></span><br><span class="line">        jobDetail.setName(<span class="string">"general-springJob"</span>); <span class="comment">// 任务的名字</span></span><br><span class="line">        jobDetail.setGroup(<span class="string">"general"</span>); <span class="comment">// 任务的分组</span></span><br><span class="line">        jobDetail.setTargetObject(springJob); <span class="comment">// 被执行的对象</span></span><br><span class="line">        jobDetail.setTargetMethod(<span class="string">"myJobBusinessMethod"</span>); <span class="comment">// 被执行的方法</span></span><br><span class="line">        <span class="keyword">return</span> jobDetail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表达式触发器工厂Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"SpringJobTrigger"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CronTriggerFactoryBean <span class="title">myFirstExerciseJobTrigger</span><span class="params">(@Qualifier(<span class="string">"SpringJobBean"</span>)</span> MethodInvokingJobDetailFactoryBean springJobBean) </span>&#123;</span><br><span class="line">        CronTriggerFactoryBean tigger = <span class="keyword">new</span> CronTriggerFactoryBean();</span><br><span class="line">        tigger.setJobDetail(springJobBean.getObject());</span><br><span class="line">        tigger.setCronExpression(<span class="string">"0/10 * * * * ?"</span>); <span class="comment">// 什么是否触发，Spring Scheduler Cron表达式</span></span><br><span class="line">        tigger.setName(<span class="string">"general-springJobTrigger"</span>);</span><br><span class="line">        <span class="keyword">return</span> tigger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>下面将任务和触发器注册到调度器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度器工厂Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"schedulerFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">schedulerFactory</span><span class="params">(@Qualifier(<span class="string">"SpringJobTrigger"</span>)</span> Trigger springJobTrigger) </span>&#123;</span><br><span class="line">        SchedulerFactoryBean bean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">        <span class="comment">// 覆盖已存在的任务</span></span><br><span class="line">        bean.setOverwriteExistingJobs(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 延时启动定时任务，避免系统未完全启动却开始执行定时任务的情况</span></span><br><span class="line">        bean.setStartupDelay(<span class="number">15</span>);</span><br><span class="line">        <span class="comment">// 注册触发器</span></span><br><span class="line">        bean.setTriggers(SpringJobTrigger);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成上述配置后，启动spring boot就可以出发定时器任务了。而且，仔细观察上面的代码，在执行过程中有<code>WriteService</code>的spring对象注入，而无需我们自己去自定义JobFactory的Spring对象。</p><h2 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4.持久化"></a>4.持久化</h2><p>任务持久化需要用到数据库，而初始化数据库的SQL可以从下载的发布版的文件中找到，比如，我在官网的Download页下载了当前版本的Full Distribution：<code>Quartz 2.2.3 .tar.gz</code>，解压后在<code>quartz-2.2.3\docs\dbTables</code>能找到初始化脚本，因我用的是MySQL的Innodb引擎，所以我用此脚本<code>tables_mysql_innodb.sql</code>。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认情况下，调度器的详情信息会被存储在内存，模式为：<code>RAMJobStore</code>，而且也不需要填写quartz.properties的配置。然而，如果是持久化的模式，那么quartz.properties就必须填写，因为文件中制定了信息存储模式和数据源信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 线程调度器实例名</span><br><span class="line">org.quartz.scheduler.instanceName = quartzScheduler</span><br><span class="line"># 线程池的线程数，即最多3个任务同时跑</span><br><span class="line">org.quartz.threadPool.threadCount = 3</span><br><span class="line"></span><br><span class="line"># 如何存储任务和触发器等信息</span><br><span class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class="line"># 驱动代理</span><br><span class="line">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="line"># 表前缀</span><br><span class="line">org.quartz.jobStore.tablePrefix = qrtz_ </span><br><span class="line"># 数据源</span><br><span class="line">org.quartz.jobStore.dataSource = quartzDataSource</span><br><span class="line"># 是否集群</span><br><span class="line">org.quartz.jobStore.isClustered = false</span><br><span class="line"></span><br><span class="line"># 数据源</span><br><span class="line"># 驱动</span><br><span class="line">org.quartz.dataSource.quartzDataSource.driver = com.mysql.cj.jdbc.Driver</span><br><span class="line"># 连接URL</span><br><span class="line">org.quartz.dataSource.quartzDataSource.URL = jdbc:mysql://localhost:3306/quartz?characterEncoding=utf-8&amp;useSSL=true&amp;&amp;serverTimezone=Asia/Shanghai</span><br><span class="line"># 用户名</span><br><span class="line">org.quartz.dataSource.quartzDataSource.user = root</span><br><span class="line"># 密码</span><br><span class="line">org.quartz.dataSource.quartzDataSource.password = 123456</span><br><span class="line"># 最大连接数</span><br><span class="line">org.quartz.dataSource.quartzDataSource.maxConnections = 5</span><br></pre></td></tr></table></figure><p>其他内容和<code>RAMJobStore</code>模式相同。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Quartz </tag>
            
            <tag> 持久化 </tag>
            
            <tag> 对象注入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA：文件下载</title>
      <link href="/posts/c0372a48/"/>
      <url>/posts/c0372a48/</url>
      <content type="html"><![CDATA[<p>如何通过Java（模拟浏览器）发送HTTP请求，下载文件是WEB应用经常处理的场景。Java有原生的API可用于发送HTTP请求，即：java.net.URL、java.net.URLConnection。这些API本身已经足够好用，但不够简便。所以，也流行有许多Java HTTP请求的framework，如Apache的HttpClient等。</p><p>目前项目主要用到Java原生的方式，所以，这里主要介绍此方式。<br><a id="more"></a> </p><h2 id="1-Get请求和Post请求"><a href="#1-Get请求和Post请求" class="headerlink" title="1.Get请求和Post请求"></a>1.Get请求和Post请求</h2><p>HTTP请求简单分为GET请求和POST请求（详见：<a href="https://tools.ietf.org/html/rfc2616#section-9" target="_blank" rel="noopener">Hypertext Transfer Protocol – HTTP/1.1 - Method Definitions</a>）。</p><p>使用Java发送这两种请求的代码大同小异，只是一些参数设置的不同。步骤如下：</p><ol><li>通过统一资源定位器（java.net.URL）获取连接器（java.net.URLConnection）</li><li>设置请求的参数</li><li>发送请求</li><li>以输入流的形式获取返回内容</li><li>关闭输入流</li></ol><p><strong>HttpURLConnection</strong>继承自<strong>URLConnection</strong>，常用它下面几个方法：</p><ul><li>-setRequestMethod：设置URL请求的方法， 如GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE。其中，GET方法是默认的，可以不写；</li><li>-setRequestProperty：设置一般请求属性，如”Accept-Charset”、”Content-Type”、”User-Agent”等；</li><li>-getResponseCode：从HTTP响应消息获取状态码；</li><li>-getResponseMessage：获取与来自服务器的响应代码一起返回的HTTP响应消息（如果有）。</li></ul><h2 id="2-下载文件"><a href="#2-下载文件" class="headerlink" title="2.下载文件"></a>2.下载文件</h2><p>文件下载请求，本质上也是一个POST请求，因此，流程大体相同。下面的示例正是按照流程顺序进行了处理。如果项目中有多处地方使用HTTP请求，我们可以适当对其进行封装。</p><h3 id="封装文件下载器"><a href="#封装文件下载器" class="headerlink" title="封装文件下载器"></a>封装文件下载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从网络Url中下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> urlStr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> savePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">downLoadFromUrl</span><span class="params">(String urlStr,String fileName,String savePath)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">    HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">    <span class="comment">//设置超时间为3秒</span></span><br><span class="line">    conn.setConnectTimeout(<span class="number">3</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//防止屏蔽程序抓取而返回403错误</span></span><br><span class="line">    conn.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 5.0; </span></span><br><span class="line"><span class="string">    Windows NT; DigExt)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到输入流</span></span><br><span class="line">    InputStream inputStream = conn.getInputStream();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//转储文件</span></span><br><span class="line">    saveToLocal(inputStream, savePath, fileName);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"info:"</span>+url+<span class="string">" download success"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行文件转储"><a href="#执行文件转储" class="headerlink" title="执行文件转储"></a>执行文件转储</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件转储</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> savePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveToLocal</span><span class="params">(InputStream in, String fileName, String savePath)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取字节流</span></span><br><span class="line">    <span class="keyword">byte</span>[] getData = readInputStream(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父文件夹位置</span></span><br><span class="line">    File saveDir = <span class="keyword">new</span> File(savePath);</span><br><span class="line">    <span class="keyword">if</span>(!saveDir.exists())&#123;</span><br><span class="line">        saveDir.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(saveDir+File.separator+fileName);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    fos.write(getData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭输入输出流</span></span><br><span class="line">    <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(in!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入流转字节流"><a href="#输入流转字节流" class="headerlink" title="输入流转字节流"></a>输入流转字节流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从输入流中获取字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] readInputStream(InputStream inputStream) </span><br><span class="line"><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">while</span>((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    bos.close();</span><br><span class="line">    <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>如果想学习如何用URLConnection发送Get请求和Post请求，可参考这篇好文：<a href="https://www.cnblogs.com/nick-huang/p/3859353.html" target="_blank" rel="noopener">通过java.net.URLConnection发送HTTP请求的方法</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> URLConnection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo：NexT主题优化之路</title>
      <link href="/posts/dc01d1e2/"/>
      <url>/posts/dc01d1e2/</url>
      <content type="html"><![CDATA[<p>选择了Hexo + Next完成个人博客建站之后，仍然会有很多不足之处。此时，万能的搜索引擎和git社区为我们提供了琳琅满目的解决方案。本文将陆续记录本站采用过的优化措施，以供大家参考。<br><a id="more"></a></p><h2 id="缩小首页文章列表间距并增加阴影效果"><a href="#缩小首页文章列表间距并增加阴影效果" class="headerlink" title="缩小首页文章列表间距并增加阴影效果"></a>缩小首页文章列表间距并增加阴影效果</h2><p>在5.1.3版本中，可以直接修改next/source/css/_custom/custom.styl文件，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line">.posts-expand &#123;</span><br><span class="line">    .post &#123;</span><br><span class="line">        margin-top: <span class="number">60</span>px;</span><br><span class="line">        margin-bottom: <span class="number">20</span>px;</span><br><span class="line">        padding: <span class="number">25</span>px;</span><br><span class="line">        -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>);</span><br><span class="line">        -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加标签"><a href="#增加标签" class="headerlink" title="增加标签"></a>增加标签</h2><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>你需要在hexo根目录的source文件夹下新建一个tags文件夹，然后在tags文件夹里面新建一个index.md文件。快捷命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "tags"</span><br></pre></td></tr></table></figure><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>编辑source/tags/index.md文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;tags&quot;</span><br><span class="line">type: tags</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><code>title</code>标题不重要，自定义。<code>comments</code>为false，可以关闭本页的评论功能。</p><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>编辑主题配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nav:</span><br><span class="line">  home: /</span><br><span class="line">  about: /about</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>文章中多个标签的添加方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">  - tag1</span><br><span class="line">  - tag2</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags: [tag1, tag2]</span><br></pre></td></tr></table></figure><h2 id="增加分类"><a href="#增加分类" class="headerlink" title="增加分类"></a>增加分类</h2><p>方法同上，区别是:</p><ul><li><code>tags</code>换成<code>categories</code>;</li><li>分类只能有一个。</li></ul><p>文章中增加<code>categories: xxx</code>。</p><h2 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>支持站内搜索需要<code>hexo-generator-search</code>和<code>hexo-generator-searchdb</code>两个插件，在站点的根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><h3 id="启用搜索"><a href="#启用搜索" class="headerlink" title="启用搜索"></a>启用搜索</h3><p><strong>第一步：</strong>在hexo的_config.yml配置文件增加如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>在NexT的_config.yml配置文件修改如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h2 id="修改Pisces主题内容区宽度"><a href="#修改Pisces主题内容区宽度" class="headerlink" title="修改Pisces主题内容区宽度"></a>修改Pisces主题内容区宽度</h2><p>默认的宽度觉得有点窄，想改宽一点，可以在<code>source/css/_schemes/Picses/_layout.styl</code>文件末尾添加如下代码:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*扩展宽度*/</span></span><br><span class="line"><span class="selector-tag">header</span>&#123; <span class="attribute">width</span>: <span class="number">80%</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-tag">header</span><span class="selector-class">.post-header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123; <span class="attribute">width</span>: <span class="number">80%</span>; &#125;</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123; <span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 260px); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="selector-tag">width</span>: <span class="selector-tag">auto</span> !<span class="selector-tag">important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +<span class="selector-tag">mobile</span>() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="selector-tag">width</span>: <span class="selector-tag">auto</span> !<span class="selector-tag">important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +<span class="selector-tag">mobile</span>() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="selector-tag">width</span>: 100% !<span class="selector-tag">important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +<span class="selector-tag">mobile</span>() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去掉图片默认的边框"><a href="#去掉图片默认的边框" class="headerlink" title="去掉图片默认的边框"></a>去掉图片默认的边框</h2><p>将Next主题/themes/next/source/css/_common/components/post/post-expand.styl文件中的img的border的值修改为none</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将border的值修改为none即可去掉边框，默认值为 1px solid $gray-lighter</span><br><span class="line">  img &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    margin: auto;</span><br><span class="line">    padding: 3px;</span><br><span class="line">    border: none; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="持久化链接优化"><a href="#持久化链接优化" class="headerlink" title="持久化链接优化"></a>持久化链接优化</h2><p>写的文章复制到微信中链接被分开了，无法直接点击链接访问。看了其他人的博客，大多数是转换为英文的，也没说实现方法。看到一个abbrlink的方法，使用解决了这一问题。</p><h3 id="安装abbr-link插件"><a href="#安装abbr-link插件" class="headerlink" title="安装abbr-link插件"></a>安装abbr-link插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><h3 id="配置博客站点文件"><a href="#配置博客站点文件" class="headerlink" title="配置博客站点文件"></a>配置博客站点文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink/</span><br><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  #support crc16(default) and crc32</span><br><span class="line">  rep: hex    #support dec(default) and hex</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>执行<code>hexo clean</code>和<code>hexo s</code>，使得配置生效</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> tags </tag>
            
            <tag> 文章阴影 </tag>
            
            <tag> 文章列表间距 </tag>
            
            <tag> 搜索，Pisces </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>足迹：龙门古镇</title>
      <link href="/posts/7fc1a8e1/"/>
      <url>/posts/7fc1a8e1/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201706031024.jpg?imageView2/2/w/1536"><a id="more"></a><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201706031123.jpg?imageView2/2/w/1536"><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201706031212.jpg?imageView2/2/w/1536"><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201706031220.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>足迹：六和塔</title>
      <link href="/posts/55828a88/"/>
      <url>/posts/55828a88/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201704041041.jpg?imageView2/2/w/1536"><a id="more"></a><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201704041159.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>足迹：九溪十八涧</title>
      <link href="/posts/caeb5da5/"/>
      <url>/posts/caeb5da5/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201704031126.jpg?imageView2/2/w/1536"><a id="more"></a><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201704031144.jpg?imageView2/2/w/1536"><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201704031153.jpg?imageView2/2/w/1536"><h2 id="2017-04-03"><a href="#2017-04-03" class="headerlink" title="2017-04-03"></a>2017-04-03</h2><p>清明假期第二天，天气晴好，阳光明媚。</p><p>老婆刚刚确认怀孕，岳母也是大病初愈。一家人也算是一扫16年的阴霾，心情大好地出门去近郊踏青。</p><p>从九溪公交车站往里走，人是越来越多，但是风景更是越来越好。初入景区，左边是湍流的溪水，右边是漫山的茶园。耳边响起的是溪涧奔流的叮咚声，鼻子嗅到的是明前龙井的清新，更有游人的欢声笑语和采茶女穿梭山间茶园倩影。眼前的风景，让人不禁赞叹春光无限好。</p><p>到达九溪烟树的石碑，是一路美丽风光的顶峰。图一的照片正是九溪风景的名片。我认为秋天才是九溪烟树最美的季节，不同的植被在这个季节会披上不同的颜色，有红的似火的枫叶，有金黄的梧桐，有万年长青的香樟，连溪水的颜色都会不同。恰似倒翻了的颜料盘，在大自然打开了五彩斑斓的画卷。想不到的是春天的景观也不逊色，虽不是暖色调为主，但是嫩绿、翠绿、深绿，层次分明，错落有致的绿色，让我们感受到沁人心脾的清新自然，心旷神怡。</p><p>图二是我和丈母娘看到有人在那里拍婚纱照，料定必有美景，便一同前往。碧玉般的湖水和青山，在红绿相间的枝叶半遮半掩之下，绘制出一番犹抱琵琶半遮面的羞涩意境，更惹人喜爱。连累得在九曲桥上休息的老婆和丈人，看了我手机拍下的照片，也想重新启程，亲览美景。</p><p>图三则是在返程的路上，路过一步长的小桥拍下的。九溪的美正如这张照片，不经意之间的一瞥，邂逅的可能就是百看不厌的传世画卷。</p>]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 九溪十八涧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>足迹：湘湖</title>
      <link href="/posts/2500110d/"/>
      <url>/posts/2500110d/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201701141320.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>足迹：白马湖</title>
      <link href="/posts/58ecbb5a/"/>
      <url>/posts/58ecbb5a/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201701081204.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>足迹：千岛湖</title>
      <link href="/posts/20a3881c/"/>
      <url>/posts/20a3881c/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201701010826.jpg?imageView2/2/w/1536"><a id="more"></a><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201701011212.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>足迹：乌镇</title>
      <link href="/posts/5f961822/"/>
      <url>/posts/5f961822/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201612251316.jpg?imageView2/2/w/1536"><a id="more"></a><img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201612251455.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>足迹：迪士尼</title>
      <link href="/posts/b2af91bf/"/>
      <url>/posts/b2af91bf/</url>
      <content type="html"><![CDATA[<img src="http://p8v39fxp8.bkt.clouddn.com/static/images/201609040902.jpg?imageView2/2/w/1536">]]></content>
      
      <categories>
          
          <category> 足迹 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
